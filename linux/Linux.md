# Linux-v10.0-01天-课堂笔记

学习目标

- 能够知道什么是Linux系统以及它的应用场景
- 能够独立完成安装VMware虚拟机和网络配置
- 能够独立完成安装CentOS以及远程终端SecureCRT
- 能够熟练编写账户管理、用户组的增删改查和添加命令
- 能够熟练编写系统管理的常用命令
- 能够熟练编写目录常用命令
- 能够熟练编写权限常用命令
- 能够知道用户组实际应用场景

# 1 初识Linux

```
在前面的课程中，我们无论是开发、测试。部署、存储都在Windwos操作系统的环境中，从今天开始我们一起学习下Linux,Linux系统和Windows系统最大的区别就是图形化界面操作和用途上有所差异，除了这两点，两者有异曲同工之妙，在国内， Linux 系统更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows，也就是说Linux与Windows一样，同样也是操作系统只是在使用以及应用上有所差异，其他都是一样的；
因为Linux也是操作系统
所以在正式进入Linux学习之前，我们先简单的学习操作系统的知识，然后在讲解Linux
```

## 1.1 操作系统

操作系统(Operation System, OS)，是管理[计算机](https://baike.baidu.com/item/计算机)[硬件](https://baike.baidu.com/item/硬件)与[软件](https://baike.baidu.com/item/软件)资源的[计算机程序](https://baike.baidu.com/item/计算机程序)，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置[内存](https://baike.baidu.com/item/内存)、决定[系统资源](https://baike.baidu.com/item/系统资源/974435)供需的优先次序、控制[输入设备](https://baike.baidu.com/item/输入设备/10823368)与[输出设备](https://baike.baidu.com/item/输出设备/10823333)、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。

操作系统作为接口的示意图:

![1576199620565](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576199620565-1614758277353.png)

如上图所示，在操作系统的最上层是用户，中间层是操作系统（里面可能装了很多的应用程序），最下层是硬件的支撑，包含CPU/内存/硬盘等

这就是一个完成的操作系统结构图

**主流操作系统按照应用领域的划分**

**1、桌面操作系统**

- Window 系列
  - 用户群体大
- macOS
  - 细节处理的更好, 没有windows软件丰富, 价格高
- Linux
  - 应用软件少

**2、服务器操作系统**

- Linux

  - 安全、稳定、免费
  - 占有率高

- Windows Server

  - 付费
  - 占有率低

  ![1558234034446](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1558234034446-1614758277354.png)

**3、嵌入式操作系统**

​    Linux

**4、移动设备操作系统**

 ![1560477460567](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1560477460567-1614758277354.png)

- IOS
- Android (基于Linux)
- 华为鸿蒙(基于linux)

## 1.2 Linux发展历程

```
引子
在上面，我们学习了操作系统的知识，也知道了主流操作系统按照应用领域划分了四个类型的操作系统，其中Linux操作系统在四个领域都有提名，因为它是至今开源序列最好的操作系统，下面，我们就一起看下Linux的发展历程，看看它是怎么诞生的...
```

1984年，Andrew S.Tanenbaum 开发了用于教学的Unix系统，命名为Minix，但是仅仅用于教学
1989年，Andrew S.Tanenbaum将Minix系统运行于x86的pc平台
1990年，芬兰赫尔辛基大学学生Linus Torvalds首次接触Minix系统
1991年，Linus Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件
1991年年底，Linus Torvalds公开了Linux内核源码0.02版，仅仅是内核
1994年，Linux 1.0版本发行，Linux转向GPL版权协议
至此，Linux开始盛行开来...

![1575879660267](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1575879660267-1614758277354.png)

Linux 内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 Unix操作系统 Minix 太难用了，于是决定自己开发一个操作系统。

第 1 版本于 1991 发布，当时仅有 10 000 行代码。

李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。

据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。

> Unix  
>
> Unix  操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。
>
> Unix是一个强大的多用户、多任务操作系统。于1969年在AT&T的贝尔实验室开发。Unix  的商标权由国际开放标准组织（The Open Group）所拥有。Unix操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。

## 1.3 Linux简介

```
引子
Linux和我们常见的Windows一样，都是操作系统，
例如：新浪、百度、淘宝等互联网公司，他们使用的服务器全都是Linux系统；全球500强企业95%的服务器使用的都是Linux系统。
```

### **1.3.1 什么是 Linux**

Linux是一套免费使用和自由传播的[类Unix](https://baike.baidu.com/item/类Unix)[操作系统](https://baike.baidu.com/item/操作系统/192)，是一个基于[POSIX](https://baike.baidu.com/item/POSIX)和Unix的多用户、[多任务](https://baike.baidu.com/item/多任务/1011764)、支持[多线程](https://baike.baidu.com/item/多线程/1190404)和多[CPU](https://baike.baidu.com/item/CPU)的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持[32位](https://baike.baidu.com/item/32位/5812218)和[64位](https://baike.baidu.com/item/64位)硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

Linux 的标志和吉祥物是一只名字叫做Tux(它克斯)的企鹅，Linux是基于Unix的。

Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机

![1575881750752](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1575881750752-1614758277354.png)

Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作[服务器](https://baike.baidu.com/item/服务器/100571)，又可以当作网络防火墙是Linux的 一大亮点。 

Linux与其他操作系统相比 ，具有[开放源码](https://baike.baidu.com/item/开放源码/7176422)、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。

### 1.3.2 Linux的特点

**基本思想**

Linux的基本思想有两点：

第一：一切都是文件

第二：每个软件都有确定的用途

其中第一条详细来讲就是系统中的所有都归结为一个文件，包括[命令](https://baike.baidu.com/item/命令)、[硬件](https://baike.baidu.com/item/硬件)和[软件](https://baike.baidu.com/item/软件/12053)设备、[操作系统](https://baike.baidu.com/item/操作系统/192)、[进程](https://baike.baidu.com/item/进程)等等对于操作系统[内核](https://baike.baidu.com/item/内核)而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近

**完全免费**

Linux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其[源代码](https://baike.baidu.com/item/源代码/3969)。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数[程序员](https://baike.baidu.com/item/程序员/62748)参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。

**完全兼容POSIX1.0标准**

这使得可以在Linux下通过相应的[模拟器](https://baike.baidu.com/item/模拟器)运行常见的[DOS](https://baike.baidu.com/item/DOS/32025)、[Windows](https://baike.baidu.com/item/Windows)的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。

**多用户、多任务**

Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。[多任务](https://baike.baidu.com/item/多任务)则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。

**良好的界面**

Linux同时具有字符界面和[图形界面](https://baike.baidu.com/item/图形界面/8146283)。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。

**支持多种平台**

Linux可以运行在多种硬件平台上，如具有[x86](https://baike.baidu.com/item/x86/6150538)、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持[Intel](https://baike.baidu.com/item/Intel/125450)64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。

**优点**

1)Linux由众多微内核组成，其源代码完全开源；

2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/[IPv4](https://baike.baidu.com/item/IPv4/422599)、 [TCP](https://baike.baidu.com/item/TCP/33012)/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈；

3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性；

## 1.4 Linux和Unix区别

**1、开源情况**

Unix  是商业化的，而 Linux 是开源的，是免费、公开源代码的。

**2、硬件适用**

Unix  系统大多是与硬件配套的，也就是说，大多数Unix系统如AIX、HP-UX等是无法安装在 x86 服务器和个人计算机上的，而 Linux则可以运行在多种硬件平台上。

可以先学习Linux后再学习Unix，因为Linux可以方便的在虚拟机上运行，防止新手的误操作。

**3、本质不同**

Linux是开放源代码的自由软件，用户对前者有很高的自主权，在实际的的开发是处在一个完全开放的环境之中；

而Unix是对源代码实行知识产权保护的传统商业软件，用户的开发完全是处在一个黑箱之中，只有相关的开发人员才能够接触的产品的原型；

> Unix 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 Unix是操作系统中的"老大哥"，后来的 Windows 和 Linux 都参考了 Unix 

##  1.5 Linux和Windows区别

目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下

| 比较     | Windows                                                      | Linux                                                        |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 界面     | 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 | 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 Unix传承下来，基本命令和操作方法也几乎一致。 |
| 驱动程序 | 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 | 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 |
| 使用     | 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 | 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。     |
| 学习     | 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。   | 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 |
| 软件     | 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 | 大部分软件都可以自由获取，同样功能的软件选择较少。           |

Windows与Linux在其他方面的不同

**开放性**

所谓的开放性就是Linux 操作系统是开放源码系统，可以对其程序进行编辑修改。而微软的Windows 系统是受微软版权保护，就是只能微软内部进行开发及修改。

**文件格式不同**

Windows 操作系统内核是NT，而Linux 是 shell；

另外，windows 硬盘文件格式是fat32或NTFS，而Linux 需要的文件格式是ext2或ext3，该操作系统还多一个SWAP格式的交换分区

**免费与收费** 

在中国，对个人用户Windows 和Linux 都是免费的，对公用户Windows 需要收费，Linux 是免费的。

**技术支持** 

Windows 较普及。Linux 需要深度的Linux 版块支持。

**安全性** 

Linux 相对Windows 来说安全性更高。 

**开源** 

开源就是指对外部开放软件源代码。Linux 开源，而Windows并不开源。

**使用习惯** 

Windows 放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux 字符模式运行的更好，图形界面还只是附带品，可有可无。

**软件与支持** 

Windows 下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux 下可直接运行的软件数量和win下比起来就是1和99的区别，而且目前选择Linux 的人基本不会考虑玩游戏，同时Linux 正期待更多硬件厂商的支持

## 1.6 Linux发行商和常见发行版

Linux发行版是由个人，自由组织，以及商业机构和志愿者组织编写。它们通常包括了其他的系统软件和应用软件，以及一个用来简化系统初始安装的安装工具，和让软件安装升级的集成管理器。大多数系统还包括了像提供GUI界面的XFree86之类的曾经运行于BSD的程序。
一个典型的Linux发行版包括：Linux内核，一些GNU程序库和工具，命令行shell，图形界面的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件

Linux发行版的某些版本是不需要安装，只需通过CD或者可启动的USB存储设备就能使用的版本，他们称为LiveCD。


 ![1575879998775](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1575879998775-1614758277354.png)



**Linux的版本号分为两部分：内核版本和发行版本**。

**1．Linux的内核版本**
内核版本指的是在Linus Torvalds领导下的开发小组开发出的系统内核的版本号，通常，内核版本号的第二位是偶数表示是稳定的版本，如2.6.25；是奇数表示有一些新的东西加入，是不稳定的测试版本，如2.5.6。Linux操作系统的核心就是它的内核，Linus Torvalds和他的小组在不断地开发和推出新内核。

任务：进程调度、内存管理、配置管理虚拟文件系统、提供网络接口以及支持进程间通信。像所有软件一样，Linux的内核也在不断升级。

**2．Linux的发行版本**
一个完整的操作系统不仅仅只有内核，还包括一系列为用户提供各种服务的外围程序。外围程序包括GNU程序库和工具，命令行shell，图形界面的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。所以，许多个人、组织和企业，开发了基于GNU/Linux的Linux发行版，他们将Linux系统的内核与外围应用软件和文档包装起来，并提供一些系统安装界面和系统设置与管理工具， 这样就构成了一个发行版本。
实际上，Linux的发行版本就是Linux内核再加上外围的实用程序组成的一个大软件包而已。相对于操作系统内核版本，发行版本的版本号是随发布者的不同而不同，与Linux系统内核的版本号是相对独立的，例如：RedHat EnterpriseLinux 5.2的操作系统内核是Linux-2.6.18。
Linux的发行版本大体可以分为两类：

一类是商业公司维护的发行版本

一类是社区组织维护的发行版本，前者以著名的RedHatLinux为代表，后者以Debian为代表

以下为Linux的主流版本：

目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等

![1575882315996](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1575882315996-1614758277354.png)



**以下是主要的发行版本**

```
需要注意的：
下面的内容主要是介绍了下Linux发行家族以及发行版本的一些详细信息，虽然我们当前的课程讲解的是CentOS,但是其他的一些发行商、主流的发行版本比如Ubuntu、Redhat也需要让学生多多了解下，毕竟这是Linux体系内产品线
注意
下面的文字虽然很多，但是只要让学生知道有这么回事即可
在下面会简单的总结..
```

**1、Debian 介绍**

Debian名字的由来----DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb。

Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由 Ian Murdock于1993年创建，分为三个版本分支： stable(服务器版), testing(稳定版) 和unstable(测试版)。

**2、Ubuntu介绍**

Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。

共分三个版本:

- 基于Gnome的Ubuntu，
- 基于KDE的Kubuntu以。
- 基于Xfc的 Xubuntu。

特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。稳定性，其实都差不多，难易度嘛，

Ubuntu 默认桌面环境采用 GNOME，一个 Unix和 Linux 主流桌面套件和开发平台。

Ubuntu的版本和发布号 
Ubuntu的版本号是由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布是在2004年10月，因此该版本为4.10。当前版本(DapperDrake)于2006年6月发布，因此版本号为6.06 LTS。

**3、Redhat**

可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。
Red Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。
Red Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力

**4、Fedora**

Fedora和Redhat这两个Linux的发行版放联系很密切。Redhat 自9.0以后，不再发布桌面版的，而是把这个项目与开源社区合作，于是就有了Fedora 这个 Linux 发行版。Fedora项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。

特点：
１、 Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。可运行的体系结构包括x86(即i386),x86_64 和PowerPC！
２、Fedora 可以说是Redhat 桌面版本的延续，只不过是与开源社区合作。

３、Fedora 是一个独立的inux发行版本的操作系统。

**5**、**centos**

CentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境


**6、Slackware介绍**

Slackware 由PatrickVolkerding(帕特里克.沃克登)创建于1992年。算起来应当是历史最悠久的Linux发行版。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的 Linux老手）。Slackware稳定、安全，所以仍然有大批的忠实用户。由于Slackware尽量采用原版的软件包而不进行任何修改，所以制造新 bug的几率便低了很多。Slackware的版本更新周期较长（大约1年），但是新版本的软件仍然不间断的提供给用户下载。

**7、openSUSE介绍**

SUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统也大受好评。SUSE于2003年年末被Novell收购。SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。

openSUSE 项目是由Novell公司资助的全球性社区计划，旨在推进 Linux 的广泛使用。这个计划提供免费的openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标—创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。

openSUSE 项目是由Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。

**8、中国大陆的Linux发行版**

红旗Linux(RedflagLinux) ，冲浪Linux(Xteam Linux) ，蓝点Linux ， GNU/Linux，OpenDesktop等等 。

**9、 台湾地区的Linux发行版**

鸿奇Linux

**目前最著名的发行版本：Debian，ubuntu、OpenSuse(原Suse)、CentOS、fedora等。国内比较著名的红旗Linux版本**



> 对于上面的知识我们做下重点总结
>
> - **redhat**：目前，全球最大的**linux**发行厂商，功能全面、稳定。
>   - **Redhat** 被 **IBM** 收购!
> - **ubuntu**：目前，是linux桌面操作系统做的最好的。
> - **centos**：免费版的redhat，**centos** 基于 **redhat** 发行版基础之上，再重新编译发布的版本。
>   - 目前 **centos** 已经被 **Redhat** 公司收购，但是依然免费



## 1.7 Linux 应用领域

今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位。在企业级开发中，我们通常使用Linux作为我们的服务器。

比如：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 

嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。

**目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎**。

- 巴西联邦政府由于支持 Linux 而世界闻名。
- 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。
- 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。
- 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。
- 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。
- 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。
- 法国和德国同样开始逐步采用 Linux。

## **1.8 Linux之CentOS**

```
前面章节介绍了一些Linux的基本知识，前已经对Linux有了一个初步的认识，也知道了在Linux发行版中有各个家族的发行版本；比如比较知名的ubuntu、CentOS，在今天的Linux课程中我们将采用发行版CentOS作为我们Linux课程的讲解内容。
```

**CentOS**，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台

**主要特点:**

1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS
2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本
3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！

**我们在当前课程中的环境：**

Windows7 , VMware Workstation15.02, CentOS Linux release 7.6.1810 

## 1.9 总结

当前章节主要介绍了Linux发行的主要版本（我们使用的是CentOS Linux release 7.6.1810 ）、以及与Unix、Windows系统的区别；主要让学生了解Linux是基于Unix的以及与Windows一样，Linux也是操作系统即可。



# CRT

CRT stands for "Combined Rlogin and Telnet."

SecureCRT是一款支持[SSH](https://baike.baidu.com/item/SSH)（SSH1和SSH2）的[终端仿真](https://baike.baidu.com/item/终端仿真/3441931)程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。

SecureCRT支持SSH，同时支持[Telnet](https://baike.baidu.com/item/Telnet)和rlogin协议。SecureCRT是一款用于连接运行包括[Windows](https://baike.baidu.com/item/Windows)、[UNIX](https://baike.baidu.com/item/UNIX)和VMS的理想工具。通过使用内含的VCP命令行程序可以进行[加密](https://baike.baidu.com/item/加密)文件的传输。有流行CRTTelnet客户机的所有特点,包括:自动注册、对不同主机保持不同的特性、打印功能、颜色设置、可变屏幕尺寸、用户定义的键位图和优良的VT100,VT102,VT220和ANSI竞争.能从命令行中运行或从浏览器中运行.其它特点包括文本手稿、易于使用的工具条、用户的键位图编辑器、可定制的[ANSI](https://baike.baidu.com/item/ANSI)颜色等.SecureCRT的SSH[协议支持](https://baike.baidu.com/item/协议支持/1152217)DES,3DES和RC4密码和密码与[RSA](https://baike.baidu.com/item/RSA)鉴别。



# 2 系统与设置命令



## 2.0区别快照和克隆







```
在前面的两个章节中，我们主要介绍了Linux基本知识和虚拟机的安装，从当前章节开始，我们一起学习下Linux的基本命令，在当前章节，我们先简单的学习下一些系统的基本命令，慢慢的由浅入深，在后面的章节中我们将学习其他的命令比如文件操作、备份压缩等
```

![image-20210303213525479](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210303213525479.png)

## 2.1 学习命令的原因

```
命令我们可以理解成在Windows中我们常常为了查看ip输入的ipconfig，在Linux中也有很多的命令，比如操作目录、文件、网络、磁盘等等命令
```

- Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 **磁盘操作、文件存取、目录操作、进程管理、文件权限** 设定等
- 在职场中，大量的 **服务器维护工作** 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成

![1576225778294](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576225778294-1614758277354.png)

在职场中， 作为后端程序员或者运维， 必须要或多或少的掌握一些Linux常用的终端命令

- Linux发行版本的命令大概有200多个， 但是常用的命令只有几十个而已

```
总结
学习终端命令的技巧：
- 不需要死记硬背， 对于常用命令， 记住语法是关键，在用的时候去查下参数选项，有的很常用的命令，用的多自然就记住了
- 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到，就去根据语法找参数选项
```

## 2.2 Linux 用户和用户组管理

### 2.2.1 Linux账号管理

```
从当前章节开始，我们正式进入CentOS的学习，我们先从简单的命令开始，比如操作账号、用户组、系统管理等。
在实际使用场景中，用户账号的管理主要涉及到用户账号的添加、修改和删除操作。
现在，我们就通过命令的方式添加用户账号（账号名字可以自定义，但是是要符合书写规范）
在操作前，确保我们的SecureCRT成功连接到了虚拟机.
下面的章节不在赘述SecureCRT，默认已经成功连接。
```

#### 1) 添加用户

```
我们在Windows创建账号主要是是控制面板--用户账户--创建一个新账户，这是在Windows创建账户的流程，而在Linux中，我们可以通过命令的方式进行创建账户
```

**使用者权限：管理员用户**

```shell
useradd 选项 用户名
```

**参数说明：**

- 选项:

  - -c comment 指定一段注释性描述。
  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  - -g 用户组 指定用户所属的用户组。
  - -G 用户组，用户组 指定用户所属的附加组。
  - -s Shell文件 指定用户的登录Shell。
  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

- 用户名:

  指定新账号的用户名(后续我们可以使用这个用户名进行系统登录)。

添加用户czbk（传智播客的首拼）执行

```shell
useradd  czbk
```

我们使用useradd命令创建了一个用户czbk

useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。

执行如下

![1576043805214](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576043805214-1614758277354.png)

由上图我们发现，我们在使用useradd新增用户的时候，出现了权限不足，也就是说我们使用用户itcast没有创建用户的权限。

我们通过管理员账号root进行创建，首先我们从控制台中切换到root

```shell
su root
```

![1576042675759](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576042675759-1614758277354.png)

在 密码的地方输入我们的root密码【root】即可进入到root用户下。

我们在root下继续创建czbk用户

![1576043845543](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576043845543-1614758277354.png)

以下是useradd常用选项

![1576049906893](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576049906893-1614758277354.png)



#### 2) 用户口令

```
引子：
相当于我们在Windows系统中给个用户更改密码，只是我们在CentOS中是更改密码是通过命令完成的。
```

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用

**使用者权限：管理员用户**

指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：

```shell
passwd 选项 用户名
```

可使用的选项：

- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。

设置当前用户的口令

```shell
passwd czbk
```

此处我们设置密码和itcast账号密码一致，为【Itheima888】

![1576044108094](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576044108094-1614758277354.png)

#### 3) 修改用户

```
相当于我们在Windows系统中修改一个用户，只是我们在CentOS中是修改用户是通过命令完成的。
```

usermod 命令通过修改系统帐户文件来修改用户账户信息

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

**使用者权限：管理员用户**

修改已有用户的信息使用`usermod`命令，其格式如下：

```shell
usermod 选项 用户名
```

下面命令将用户czbk用户名修改成czbk2019

```shell
usermod -l czbk2019  czbk
```

![1576046509680](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576046509680-1614758277354.png)

以下是usermod常用选项

![1576049946335](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576049946335-1614758277354.png)

#### 4) 删除用户

```
相当于我们在Windows系统中删除一个用户，只是我们在CentOS中是删除用户是通过命令完成的。
```

假如我们其中一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。

**使用者权限：管理员用户**

删除一个已有的用户账号使用`userdel`命令，其格式如下：

```shell
userdel 选项 用户名
```

-f：强制删除用户，即使用户当前已登录;

-r：删除用户的同时，删除与用户相关的所有文件

此命令删除用户czbk2019

```shell
userdel czbk2019
```

![1576047020612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576047020612-1614758277354.png)

成功删除用户czbk2019

以下是userdel常用选项

![1576049978916](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576049978916-1614758277354.png)

### 2.2.2 Linux用户组

**引子：**

**为了方便用户管理, 提出了 组 的概念, 如下图所示**

![1576572808687](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576572808687-1614758277354.png)

**新增一个账户，它默认属于自己（账户）的组**

**比如新建账户【张三】，那么它默认对应的组就是张三**

**一个用户可以有一个或者多个组**

**假如说（如上图），我们在企业级开发过程中，我们有多个组，其中一个开发组对应三个账户，张三、李四、王五、如果就像上面提到的，一个用户默认对应一个组，那么三个账户张三、李四、王五就有了三个不同的组，如果大家都操做一个文件，在进行权限分配的时候，就要对不同的三个组进行授权，显然这样是不合理的，因为太过繁琐。**

**所以，才有了组（新建组）的概念，我们把张三、李四、王五统一放到【开发组】，在对文件授权的时候，我们只对【开发组】进行授权由此，这样的话【张三、李四、王五】都有相等的权利操作了。**

#### 1) 增加用户组

新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中

**使用者权限：管理员用户** 

```shell
groupadd 选项 用户组
```

使用的选项有：

- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同

新增用户组czbk-it

```shell
groupadd czbk-it
```

上面的命令向系统中增加了一个新组czbk-it，新组的组标识号是在当前已有的最大组标识号的基础上加1

以下是groupadd常用选项

![1576050003979](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576050003979-1614758277354.png)

#### 2) 修改用户组

**使用者权限：管理员用户**

```shell
groupmod 选项 用户组
```

常用的选项有：

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

```shell
groupmod  -n czbk-it-2019  czbk-it
```

上面的命令将组czbk-it的组名修改为czbk-it-2019。

![1576047810973](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576047810973-1614758277354.png)

以下是groupmod常用选项

![1576050645612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576050645612-1614758277354.png)

#### 3) 查询用户所属组

在查询用户所属的用户组前，我们先增加一个用户ituser-groups

```shell
useradd ituser-groups
```

![1576050663149](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576050663149-1614758277354.png)

要查询一个用户属于哪个用户组，使用groups命令，其格式如下

```shell
groups 用户名
```

查询用户ituser-groups属于某个用户组，执行groups命令

```shell
groups ituser-groups
```

![1576050797421](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576050797421-1614758277354.png)

由此可见，ituser-groups用户属于用户组ituser-groups（用户组默认与用户名一样）

#### 4) 删除用户组

**使用者权限：管理员用户**

要删除一个已有的用户组，使用groupdel命令，其格式如下

```shell
groupdel 用户组
```

删除czbk-it-2019用户组

```shell
groupdel czbk-it-2019
```

![1576051028346](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576051028346-1614758277354.png)

删除成功

以下是groupdel常用选项

![1576050031859](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576050031859-1614758277354.png)

### 2.2.3 将用户添加到组

```
引子：
在上面我们学习如何新增用户，也学习了如何新增用户组，在当前的小节中，我们新建一个用户、新建一个用户组、然后把新建的用户添加到新的组中
在实际开发过程中，我们通常把多个用户按照业务需求归并到统一的一个组中，进行有序管理
```

1、创建一个新的组，并添加组ID（需要切换到root用户）

```shell
groupadd -g 8888 itbj2020group
```

执行效果如下

![1576137760529](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576137760529-1614758277355.png)

2、创建3个用户（需要切换到root用户）

```shell
 useradd  itbeijinguser1
 useradd  itbeijinguser2
 useradd  itbeijinguser3
```

3、将上面三个用户添加到组itbj2020group

我们通过passwd命令将三个用户添加到组

**什么是gpasswd：**

gpasswd 是 Linux 下工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或者从组中删除。

语法

```shell
gpasswd [可选项] 组名
```

**将上面的三个用户使用gpasswd添加到组（需要切换到root用户）**

```shell
gpasswd -a itbeijinguser1 itbj2020group
gpasswd -a itbeijinguser2 itbj2020group
gpasswd -a itbeijinguser3 itbj2020group
```

**执行如下**

![1576139901757](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576139901757-1614758277355.png)

**查看用户组下所有用户（所有用户）**

> 注意
>
> 此处的grep命令我们将在文件管理章节详细讲解，这里先使用它查看下效果

```shell
grep 'itbj2020group' /etc/group
```

执行效果如下（或者直接打开/etc/group文件都可以）

![1576139987480](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576139987480-1614758277355.png)

由上图可知：三个用户全部都加入到了itbj2020group组。

## 2.3 系统管理

```
系统管理，说的就是我们的CentOS系统，它不同于Windwos，CentOS是字符界面，我们需要通过命令进行操作，在当前章节，我们先从基本命令学起，比如创建用户、设置密码、修改用户以及用户组的相关操作。也为我们后面的章节打下基础
```

### 2.3.1 日期管理

```
当前日期如果通过date进行设置，在系统重启后不会保存date的设置，常用的只是通过date命令查看日期
```

date 可以用来显示或设定系统的日期与时间

使用者权限：所有用户

**语法如下：**

```shell
date [参数选项]
```

参数

-d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号； 
-s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号； 
-u：显示GMT； 
--help：在线帮助； 
--version：显示版本信息

1、设置时间

用 -s选项可以设置系统时间，如下：

```shell
date -s "2019-12-11 16:15:00"
```

![1576052178420](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576052178420-1614758277355.png)

2、显示时间

```shell
date
```

![1576052234012](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576052234012-1614758277355.png)

**（1）UTC** 

协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。。

**（2）GMT**

即[格林尼治](https://baike.baidu.com/item/格林尼治/3065623) 平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式

**外文名:**Universal Time

**其他外文名**G.M.T.(Greenwich Mean Time)

**（3）CST**

北京时间 （中国国家标准时间）
**北京时间是中国采用国际时区东八时区的区时作为标准时间**。
北京时间并不是北京（东经116.4°）的地方时间，而是东经120°的地方时间，故东经120度地方时比北京的地方时早约14分半钟。因为北京处于国际时区划分中的东八区，同格林尼治时间（世界时）整整相差8小时（即北京时间=世界时+8小时），故命名为“北京时间”。东八区包括的范围从东经112.5°到东经127.5°，以东经120°为中心线，东西各延伸7.5°，总宽度为15°的区域。
**而中国幅员辽阔，东西相跨5个时区（即东五区、东六区、东七区、东八区、东九区5个时区）授时台必须建在地理中心地带，从而也就产生了长短波授。“北京时间”与“北京当地时间”是两个概念，  “北京时间”的发播不在北京，而在陕西蒲城（处于东七区）**

**（4）东八区**

东八区（[UTC](https://baike.baidu.com/item/UTC)/[GMT](https://baike.baidu.com/item/GMT/6026868)+08:00）是比[世界协调时间](https://baike.baidu.com/item/世界协调时间/8036498)（UTC）/[格林尼治时间](https://baike.baidu.com/item/格林尼治时间/410004)（GMT）快8小时的时区，理论上的位置是位于[东经](https://baike.baidu.com/item/东经/8661846)112.5度至127.5度之间，是东盟标准的其中一个候选时区。当格林尼治标准时间为0:00时，东八区的标准时间为08:00

```
总结：
上面提到了很多知识：即UTC/GMT/CST/东八区
总结一下就是，北京时间(中国国家标准时间CST)采用东八区区时，即：
协调世界时(UTC)+8  /   格林尼治时间(GMT)+8
也就是说+8后的时间才是北京时间
```

### 2.3.2 显示用户

logname命令用于显示用户名称。

执行logname指令，它会显示目前用户的名称

**语法为如下：**

```shell
logname [--help][--version]
```

**参数**：

- --help 　在线帮助。
- --vesion 　显示版本信息。

显示登录账号的信息

```shell
logname
```

![1576053311351](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576053311351-1614758277355.png)

### 2.3.3 su切换账户

```
引子：
比如我们在新增用户、修改用户或者操作用户组的时候常常需要切换到管理员账户，这个时候，我们就可以使用su进行快速切换
```

su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。

使用权限：所有使用者。

**语法如下：**

```shell
su 
```

变更帐号为 root 并在执行 ls 指令后退出返回原使用者

```shell
 su -c ls root
```

![1576054831537](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576054831537-1614758277355.png)

切换到root

```shell
su root
```

![1576054846742](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576054846742-1614758277355.png)

这样的话，我们就进入到了root用户下。

### 2.3.4 id命令

```
我们如果需要查看当前账号详细信息的时候，比如查看它的用户id、群组id以及所属组的时候，我们就可以使用id命令进行查看
```

 id命令用于显示用户的ID，以及所属群组的ID。

id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。

使用者权限：所有用户

**语法**

```
id [-gGnru][--help][--version][用户名称]
```

**参数说明：**

- -g或--group 　显示用户所属群组的ID。
- -G或--groups 　显示用户所属附加群组的ID。
- -n或--name 　显示用户，所属群组或附加群组的名称。
- -r或--real 　显示实际ID。
- -u或--user 　显示用户ID。
- -help 　显示帮助。
- -version 　显示版本信息。

**显示当前用户信息**

```shell
id
```

执行效果如下

![1576578213110](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576578213110-1614758277355.png)

> 总结
>
> id命令参数虽然很多
>
> 但是常用的也就是id命令，不带参数的
>
> 主要看他的uid和组信息

### 2.3.5 sudo执行

```
比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的
```

sudo:控制用户对系统命令的使用权限,root允许的操作。

通过sudo可以提高普通用户的操作权限

使用者权限：普通用户

**语法如下：**

sudo -V
sudo -h
sudo -l
sudo -v
sudo -k
sudo -s
sudo -H
sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s
sudo command

**参数说明**：

- -V 显示版本编号
- -h 会显示版本编号及指令的使用方式说明
- -l 显示出自己（执行 sudo 的使用者）的权限
- -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码
- -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）
- -b 将要执行的指令放在背景执行
- -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称
- -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）
- -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell
- -H 将环境变数中的 HOME 指定为要变更身份的使用者HOME目录（如不加 -u 参数就是系统管理者 root ）
- command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令

sudo命令使用

```shell
sudo ls
```

![1576056341831](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576056341831-1614758277355.png)

指定root用户执行指令

```shell
sudo -u root ls -l
```

![1576056180063](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576056180063-1614758277355.png)

**修改网卡配置文件**

比如，在下面的例子中，我们使用普通用户修改网卡的配置文件，在进行保存的时候，提示我们【无法打开并写入文件】，那么此时，我们可以通过sudo命令来提升自己的写入权限

执行：

```shell
 vi /etc/sysconfig/network-scripts/ifcfg-ens33 
```

执行效果如下（保存）

![1576494207598](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576494207598-1614758277355.png)

然后点击回车

![1576493914410](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576493914410-1614758277355.png)

那么我们在修改上面的 命令，使用sudo进行修改

```shell
sudo   vi /etc/sysconfig/network-scripts/ifcfg-ens33 
```

执行效果如下（键入itcast密码）

![1576494108199](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576494108199-1614758277355.png)

执行保存

![1576494276066](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576494276066-1614758277355.png)

我们发现此时就不在报错了

### 2.3.6 top命令

```
在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行
```

top命令用于实时显示 process 的动态。

使用权限：所有使用者。

**显示进程信息**

```shell
top
```

执行效果如下

![1576495173035](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576495173035-1614758277355.png)

**各进程（任务）的状态监控属性解释说明：**
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）

**显示完整命令，与top命令不同的就是command属性像是进行了命令补全**

```shell
top -c
```

执行效果如下

![1576544383182](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576544383182-1614758277355.png)

**显示指定的进程信息，以下显示进程号为6972的进程信息，CPU、内存占用率等**

```shell
 top -p 6972
```

执行效果如下

![1576544720729](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576544720729-1614758277355.png)



> top命令的用法很多
>
> 但是常用的就是top（不带参数），有的时候，在进程比较多的时候，我们常常记住进程的pid，然后通过top -p pid进行查看
>
> 也就是说，top+ top -p是经常被用到的

###  2.3.7 ps命令

```
ps命令类似于我们在Windows中通过任务管理器查看进程信息
```

Linux ps命令用于显示当前进程 (process) 的状态信息

使用者权限：所有用户

**语法如下：**

```shell
ps 
```

显示进程信息

```shell
ps -A 
```

显示指定用户信息

```powershell
 ps -u itcast
```

显示所有进程信息 

```shell
ps -ef 
```

### 2.3.8 kill命令

```
引子：
前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程
那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作
```

Linux kill命令用于删除执行中的程序或工作(可强制中断)

使用者权限：所有用户

**语法如下：**

```shell
kill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]
```

 **参数说明**：

- -l <信息编号> 　若不加<信息编号>选项，则-l参数会列出全部的信息名称。
- -s <信息名称或编号> 　指定要送出的信息。
- [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。

杀死一个进程

```shell
 kill 15642
```

强制杀死进程

```shell
kill -KILL 15642
```

彻底杀死进程

```shell
kill -9 15642
```

杀死指定用户所有进程

1.方法一 过滤出itcast用户进程 

```shell
kill -9 $(ps -ef | grep itcast) 
```

2.方法二，直接杀死

```shell
kill -u itcast
```

> 注意
>
> 上面列举了很多kill进程的命令
>
> 但是我们我们常用的就是kill -9命令，我们常常找到进程的pid
>
> 然后通过kill -9进行杀死进程

### 2.3.9 关机命令

shutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机

使用者权限：管理员用户

**语法如下：**

```shell
shutdown [-t seconds] [-rkhncfF] time [message]
```

**参数说明**：

- -t seconds : 设定在几秒钟之后进行关机程序。
- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。
- -r : 关机后重新开机。
- -h : 关机后停机。
- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。
- -c : 取消目前已经进行中的关机动作。
- -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。
- -F : 关机时，强迫进行 fsck 动作。
- time : 设定关机的时间。
- message : 传送给所有使用者的警告讯息。

立即关机

```shell
shutdown -h now
或者
shudown
```

指定1分钟后关机，1分钟关机并显示警告信息

```shell
shutdown +1 “System will shutdown after 1 minutes” 
```

![1576059932470](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576059932470-1614758277355.png)

指定1分钟后重启，并发出警告信息

```shell
shutdown –r +1 “1分钟后关机重启”
```

![1576060232485](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576060232485-1614758277355.png)

### 2.3.10 重启命令

reboot命令用于用来重新启动计算机

使用者权限：管理员、普通（需要验证）用户

**语法如下：**

```shell
reboot [-n] [-w] [-d] [-f] [-i]
```

**参数**：

- -n : 在重开机前不做将记忆体资料写回硬盘的动作
- -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里
- -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）
- -f : 强迫重开机，不呼叫 shutdown 这个指令
- -i : 在重开机之前先把所有网络相关的装置先停止

开始重新启动

```shell
reboot
```

重启效果如下

![1576136722927](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576136722927-1614758277355.png)

此时我们的虚拟机正在重启**（别忘记使用root用户执行）**

### 2.3.11 who命令

```
在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启
```

who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等

使用者权限：所有使用者都可使用。

**语法如下：**

```shell
who - [husfV] [user]
```

**参数说明**：

- -H 或 --heading：显示各栏位的标题信息列；
- -i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串；
- -m：此参数的效果和指定"am i"字符串相同；
- -q 或--count：只显示登入系统的帐号名称和总人数；
- -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；
- -w 或-T或--mesg或--message或--writable：显示用户的信息状态栏；
- --help：在线帮助；
- --version：显示版本信息

显示当前登录系统的用户

```shell
who
```

![1576143161044](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576143161044-1614758277355.png)

显示明细(标题)信息

```shell
who -H
```

![1576143218612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576143218612-1614758277355.png)

由上图可知，截止到现在只有itcast在线。

### 2.3.12 timedatectl命令

```
引子：
timedatectl是用于控制系统时间和日期。可以用来查询和更改系统时钟于设定，同时可以设定和修改时区信息。

在实际开发过程中，系统时间的显示会和实际出现不同步；我们一般为了校正服务器时间、时区的时候会使用timedatectl命令
```

使用者权限：所有使用者都可使用，设置时间需要管理员，下面会标注。

几个常见的概念，进行总结如下：

![1576550880532](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576550880532-1614758277355.png)

**显示系统的当前时间和日期，使用命令行中的timedatectl命令**

```SHELL
timedatectl status
```

执行效果如下

![1576147390352](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576147390352-1614758277356.png)

在上面的示例中，分别显示时区、CST时间和UTC时间，其中,RTC time就是硬件时钟的时间，硬件时间默认为UTC。

**查看当前时区**

```shell
timedatectl | grep Time
或者
timedatectl 
```

执行效果如下

![1576147504533](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576147504533-1614758277356.png)

上图显示中国时区

**查看所有可用的时区**

```
timedatectl list-timezones
```

执行效果如下（下面数据没有截全）

![1576147567622](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576147567622-1614758277356.png)

**设置本地时区**

```shell
timedatectl set-timezone "Asia/Shanghai"
```

执行效果如下

![1576147666007](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576147666007-1614758277356.png)

**禁用时间同步（使用管理员账户）**

```shell
timedatectl set-ntp false
在执行
timedatectl set-time "2019-03-11 20:45:00"
```

执行效果如下

![1576148429123](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576148429123-1614758277356.png)

> 注意: 如果ntp时间同步为true时无法修改时间设定，下面马上介绍

**打开ntp**

```shell
timedatectl set-ntp true
在执行
timedatectl set-time "2019-03-11 20:45:00"
```

执行效果如下（ntp时间同步为true时无法修改时间设定）

报错信息 如下

![1576226884267](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576226884267-1614758277356.png)

**启用时间同步**

NTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。

要开始自动时间同步到远程NTP服务器，在终端键入以下命令。

```shell
timedatectl set-ntp true
```

比如，在上面我们使用timedatectl set-time "2019-03-11 20:45:00"，如下图

![1576229638059](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576229638059-1614758277356.png)

此时我们执行timedatectl set-ntp true，发现时间正常同步过来了如下图

![1576229679265](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576229679265-1614758277356.png)

要禁用NTP时间同步，在终端键入以下命令

```shell
timedatectl set-ntp false
```

执行上面的 命令即可关闭ntp

> 总结
>
> 在实际使用过程中
>
> 我们经常使用timedatectl进行时区、CST、UTC的设置



### 2.3.13 clear命令

 clear命令用于清除屏幕

使用者权限：所有使用者都可使用。

**语法**

```shell
clear
```

执行clear前

![1576230100277](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576230100277-1614758277356.png)

执行clear后

![1576230123895](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576230123895-1614758277356.png)

通过执行clear命令，就可以把缓冲区的命令全部清理干净了

### **2.3.14 exit命令**

exit命令用于退出目前的shell。

执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。

```
退出码（exit status，或exit code）的约定：

0表示成功（Zero - Success）

非0表示失败（Non-Zero  - Failure）

2表示用法不当（Incorrect Usage）

127表示命令没有找到（Command Not Found）

126表示不是可执行的（Not an executable）

>=128 信号产生
```

**语法如下**

```shell
exit [状态值]
```

退出终端

```shell
# exit
```

> exit会被经常在shell中使用
>
> 我们在明天的课程【综合案例】中会使用到exit

## 2.4 总结

用户账号管理和用户组是我们在实际使用过程中常用的命令，学习完创建账号、创建组后，需要通过gpasswd命令将用户添加到组，这也是我们学习的最终目的

系统管理的常用命令都是在开发过程中经常使用到的

# 3 Linux目录管理

```
注意：
在下面的讲解中，每个命令都有很多的参数说明（选项），我们只讲其中的几个，关键是让学生掌握命令的语法；学生学习完语法后，就可以自己按照参数书写各种命令，这也是我们最终的目的。常用命令，我们在企业级开发过程中，经常书写的命令。会非常被容易记住，不常用的命令，只要我们学习完了语法之后，在去查找参数手册，会非常容易的解决我们的问题，所以，每个命令不是建立在死记硬背的基础上的，要理解语法+查找参数=解决问题
```

## 3.1 Linux 文件与目录管理

```
在Linux系统中，所有的的目录结构为树状结构，最顶级的目录为根目录 /。
在实际开发过程中，文件的操作是非常频繁也是非常重要的
下面的章节我们将学习下Linux系统所有的系统目录和文件通过命令是如何进行管理的 
```

### 3.1.1 目录常用命令

- ls:         列出目录
- cd：     切换目录
- pwd：  显示目前的目录
- mkdir：创建一个新的目录
- rmdir：删除一个空的目录
- cp:         复制文件或目录
- rm:        移除文件或目录
- mv:        移动文件与目录或修改文件与目录的名称

**自动补全**

- 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 `tab`键
- 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令

#### 1) ls (列出目录)

```
ls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细，如下图
```

【查看磁盘下的目录与文件】

![1576564124577](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576564124577-1614758277356.png)

【查看文件夹下的目录与文件】

![1576564161701](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576564161701-1614758277356.png)



注意：在Linux系统当中， ls 命令算是比较常用的命令

使用者权限：所有使用者都可使用。

**语法如下：**

```
ls [选项]  目录名称
```

**选项与参数：**

- -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)
- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)

**将根目录下的所有文件列出来(含属性与隐藏档)**

```
 ls -al ~
```

执行效果如下

![1576553470716](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576553470716-1614758277356.png)

```
 ls -l
```

![1576639252612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576639252612-1614758277356.png)

`ls -l` 可以查看文件夹下文件的详细信息, 从左到右 依次是:

- **权限（A区域）**, 第一个字符如果是 `d` 表示目录
- **硬链接数（B区域）**, 通俗的讲就是有多少种方式, 可以访问当前目录和文件
- **属主（C区域）**, 文件是所有者、或是叫做属主
- **属组（D区域）**, 文件属于哪个组
- **大小（E区域）：文件大小**
- **时间（F区域）：最后一次访问时间**
- **名称（G区域）:文件的名称**

```
ls
```

![1576553646036](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576553646036-1614758277356.png)

```
总结
以上三种是经常被使用到的命令
它们之间的区别是
ls  显示不隐藏的文件与文件夹
ls -l 显示不隐藏的文件与文件夹的详细信息
ls -al   显示所有文件与文件夹的详细信息
```

#### 2) pwd显示当前目录

```
执行pwd命令相当于我们在Windows系统路径导航栏中查看到的当前浏览位置信息
```

如下图

![1576564294612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576564294612-1614758277356.png)



pwd 是 **Print Working Directory** 的缩写，也就是显示目前所在当前目录的命令。

使用者权限：所有使用者都可使用。

**查看当前所在目录**

```
pwd -P
```

执行效果如下

![1576552719245](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576552719245-1614758277356.png)

#### 3) cd (切换目录)

```
Linux的cd切换目录，相当于我们在Windows中通过鼠标或者快捷键点开不同的目录
```

注意：在Linux系统当中， cd 命令算是比较常用的命令

cd是Change Directory的缩写，这是用来变换工作目录的命令

使用者权限：所有使用者都可使用。

**语法如下：**

```
 cd [相对路径或绝对路径]
```

在正式学习cd命令前面，我们通过下面一个座位图的形式讲解下相对路径和绝对路径是怎么表现的。

![1576465885337](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576465885337-1614758277356.png)



- **绝对路径：**
  路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。
- **相对路径：**
  路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！

**1、使用相对路径定位目标**

- 特征:  **相对路径** 输入路径时, 最前面不是以 "/" 开始的, 表示相对 **当前目录** 所在的位置
- 缺点:  参照工作目录 发生变化 相对路径也要发生变化

```
需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 

需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 
```

![1576466126779](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576466126779-1614758277356.png)

执行效果如下

```
注意：
cd ~ 表示回到根目录
```

![1576466284360](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576466284360-1614758277356.png)

**2、使用绝对路径定位目标**

- 特征: **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置
- 优点: 定位准确, 不会因为 工作目录变化 而变化

```
需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 

需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 
```

![1576466413099](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576466413099-1614758277356.png)

执行效果如下

![1576466506750](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576466506750-1614758277356.png)

> 总结
>
> - **相对路径** 在输入路径时, 最前面不是以 `/` 开始的 , 表示相对 **当前目录** 所在的目录位置
> - **绝对路径** 在输入路径时, 最前面是以 `/`  开始的, 表示 从 **根目录** 开始的具体目录位置



#### 4) mkdir(创建目录)

```
引子：
Linux的mkdir命令相当于我们在Windows中通过鼠标或者快捷键新建文件夹
```

mkdir命令用于建立名称为 dirName 之子目录

使用权限：于目前目录有适当权限的所有使用者

**语法**

```
mkdir [-p] dirName
```

**参数说明：**

- -p 确保目录名称存在，不存在的就建一个

建立一个名为jinyanlong 的子目录

```shell
mkdir jinyanlong
```

执行效果如下

![1576553229832](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576553229832-1614758277356.png)

查看新建的 文件

![1576553205885](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576553205885-1614758277356.png)

在工作目录下的 aaa目录中，建立一个名为 bbb的子目录。 若 aaa目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 aaa目录不存在，则产生错误。）

```shell
mkdir -p aaa/bbb
```

执行效果如下

> 这里为了显示更直观，我们使用了tree命令
>
> 后面在讲解到yum的时候，会详细讲解
>
> 此处先使用

![1576560522053](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576560522053-1614758277356.png)

由上图我们发现，aaa目录被强制创建，里面包含了bbb文件。

#### **5) rmdir(删空目录)**

```
Linux的rmdir命令相当于我们在Windows中通过鼠标或者快捷键删除文件夹。
稍微有点不同的就是在Linux中删除子目录的时候，如果主目录下没有了目录以及文件，会连同主目录同时删除了（需要写Linux带有P的参数）
```

rmdir命令删除空的目录

使用权限：于目前目录有适当权限的所有使用者。

**语法**

```shell
rmdir [-p] dirName
```

**参数**：

- -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。

**将工作目录下，名为 jinyanlong 的子目录删除 :**

```shell
rmdir jinyanlong
```

**在工作目录下的 aaa目录中，删除名为 bbb的子目录。若 bbb删除后，aaa目录成为空目录，则 aaa同时也会被删除**

```shell
rmdir  -p aaa/bbb
```

> 总结：
>
> rmdir  -p aaa/bbb也就是说
>
> 在删除bbb目录完成后，发现aaa目录也是空目录了，在删除完bbb后aaa也同时被删除了。

#### 6) cp(文件复制)

```
Linux的cp命令相当于我们在Windows中通过鼠标或者快捷键复制文件或者目录
```

cp命令主要用于复制文件或目录。

使用权限：于目前目录有适当权限的所有使用者

**语法**

```shell
cp [options] source dest
```

或

```shell
cp [options] source... directory
```

**参数说明：**

- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
- -f：覆盖已经存在的目标文件而不给出提示。
- -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
- -r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
- -l：不复制文件，只是生成链接文件。

我们将当前目录"aaa/"下的所有目录以及文件复制到新目录"ccc"下，输入如下命令：

**1、数据准备**

创建aaa目录并且aaa下包含bbb目录

```shell
mkdir -p aaa/bbb
mkdir -p ccc
```

执行效果如下

![1576561579056](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576561579056-1614758277356.png)

aaa目录下有bbb

ccc下面没有目录和文件

**2、执行复制**

```shell
cp –r aaa/*  ccc  
```

执行效果如下

我们将aaa下面的所有文件、目录复制到了目录c下面

![1576562978352](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576562978352-1614758277356.png)

> 总结：
>
> 用户使用该指令复制目录时，必须使用参数"-r"或者"-R"。
>
> 如果不加参数"-r"或者"-R",只复制文件，而略过目录

#### 7) rm(删除目录)

```
Linux的rm命令相当于我们在Windows中通过鼠标或者快捷键删除文件或者目录
```

rm命令用于删除一个文件或者目录。

使用权限：于目前目录有适当权限的所有使用者

**语法**

```shell
rm [options] name...
```

**参数：**

- -i 删除前逐一询问确认。
- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
- -r 将目录及以下之档案亦逐一删除。

如果我们要删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：

![1576563524635](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576563524635-1614758277356.png)

```shell
rm -r  ccc
```

执行删除，如下图

![1576563827977](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576563827977-1614758277357.png)

> 注意
>
> 文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令
>
> 如果删除文件（比如.sh 、.txt）
>
> 直接使用rm  name.txt

#### 8) mv(移动文件)

```
Linux的mv命令相当于我们在Windows中通过鼠标或者快捷键剪切（+重命名）+粘贴文件或者目录
```

mv 命令用来为文件或目录改名、或将文件或目录移入其它位置

**语法**

```shell
mv [options] source dest
mv [options] source... directory
```

**参数说明：**

- -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;
- -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;

![1576565378463](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576565378463-1614758277357.png)

将文件 aaa 更名为 bbb :

![1576565459075](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576565459075-1614758277357.png)

```shell
1、创建aaa目录、
mkdir  aaa
2、开始重命名
mv aaa bbb
```

执行后

![1576565489569](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576565489569-1614758277357.png)

将ccc目录放入ddd目录中。

注意，如果ddd目录不存在，则该命令将ccc改名为ddd。

```shell
创建ccc
mkdir ccc
```

![1576565710078](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576565710078-1614758277357.png)

```shell
开始移动
mv ccc/ ddd 
```

![1576565800010](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576565800010-1614758277357.png)

由上图我们发现，由于ddd目录不存在，所以在mv的时候将ccc目录改名为了ddd。

## 3.2 Linux 文件基本属性

```
在Wndows系统中，我们可以选中一个文件，右键属性，可以查看到这个文件的文件类型（基本信息），以及文件的权限信息，在Linux中，它是通过不同字符的排序顺序来表示文件的类型以及权限所属信息的。
```

Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

下面我们就一起学习下Linux系统不同权限的文件和目录在怎么表示的

在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：

```shell
ls -l
```

![1576032746450](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576032746450-1614758277357.png)

实例中，bin文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。

在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。

- 当为[ **d** ]则是目录
- 当为[ **-** ]则是文件；
- 若是[ **l** ]则表示为链接文档(link file)；（windows中的快捷方式）
- 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。

每个文件的属性由左边第一部分的10个字符来确定（如下图）。

![1576460571985](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576460571985-1614758277357.png)

从左至右用0-9这些数字来表示。

第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。

第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。



其中，第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；

第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。

## 3.3 Linux文件属主和属组

```
引子：
对于一个文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。
也就是所谓的属主，它属于哪个用户的意思。
除了属主，还有属组，也就是说，这个文件是属于哪个组的（用户所属的组）。
文件的【属主】有一套【读写执行权限rwx】
文件的【属组】有一套【读写执行权限rwx】
还有它权限，下面我们在介绍
```

![1576402570345](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576402570345-1614758277357.png)

在以上实例中，aaa文件是一个目录文件，属主和属组都为 itcast，属主有可读、可写、可执行的权限（rwx）；与属主同组的其他用户有可读可写和可执行的权限（rwx）；其他用户也有可读和可执行的权限（r-x）。

### **3.3.1 chgrp更改属组**

```
实际开发中我们经常会创建新建目录和文件，一般情况下，通过命令进行新建，
在创建完成后，使用不同的用户访问，可能就会出现报错，无法访问等等问题。
然后经过一番这查找,发现该有的文件都在，大小写也没问题，路径也没问题
其实并不是这些问题。而是权限问题导致我们无法访问！是因为一个文件默认隶属于一个属组，而使用其他用户访问这个文件肯定无法访问(因为访问用户所属的组和文件所在的不是同一个组)
那么怎么可以正常访问呢？其实就是通过更改用户组（用户组、文件组）来解决这些问题
```

chgrp命令用于变更文件或目录的所属群组。

文件或目录权限的的拥有者由所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可

为了方便初学者记忆，可以将 chgrp 理解为是 "change group" 的缩写

**语法如下**

```
chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]
```

**改变文件的群组属性**

我们通过root用户进入（如下图），上接上面的例子

我们的aaa文件的属主和属组都属于itcast（如下图）

![1576407437975](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576407437975-1614758277357.png)

我们现在通过chgrp命令将文件aaa的属组更改成root（其他也可以）

```shell
chgrp -v root aaa
```

执行效果如下

![1576407536566](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576407536566-1614758277357.png)

我们通过下面的命令查询文件aaa的属组是否发生了变化，执行

```
ls -l
```

![1576407585301](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576407585301-1614758277357.png)

由上图我们发现，文件aaa的属组由itcast变成了root

这样的话，文件的属组就发生了变化。



### 3.3.2 chown更改属主和属组**

```
我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限(属主)
我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组（属组），然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的
```

Linux是多任务操作系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限

使用权限 : 管理员账户

**语法如下**

```
chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
```

我们通过root用户进入（如下图），上接上面的例子

我们的aaa文件的属主属于itcast、属组属于root

我们现在通过chgrp命令将文件aaa的属主更改成root，执行

```
 chown  root aaa
```

效果如下

![1576407880885](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576407880885-1614758277357.png)

我们通过下面的命令查询文件aaa的属主是否发生了变化，执行

```
ls -l
```

![1576407928200](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576407928200-1614758277357.png)

由上图我们发现，文件aaa的属主和属组都变成了root。

**我们将aaa文件的拥有者与群组改回为itcast：**

注意：chown命令可以更改属主和属组

```
chown itcast:itcast aaa
```

我们通过下面的命令查询文件aaa的属主是否发生了变化，执行

```
ls -l
```

![1576408146911](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576408146911-1614758277357.png)

由上图可知，aaa文件的属主和属组都被更改回来了。

### 3.3.3 chmod权限命令

Linux文件属性有两种设置方法，一种是数字，一种是符号

Linux的文件调用权限分为三级 : 文件属主、属组、其他。利用 chmod 可以控制文件如何被他人所调用。

**使用权限 : 所有使用者**

**语法**

```
chmod [-cfvR] [--help] [--version] mode file...
```

**参数说明**


mode : 权限设定字串，格式如下

```
[ugoa...][[+-=][rwxX]...][,...]
```

**解释：**

u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。

+表示增加权限、- 表示取消权限、= 表示唯一设定权限。
r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。

#### **1) 数字权限**

Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组（owner/group/others就是所说的三个一组 ）的，我们也可以使用数字来代表各个权限，各权限的分数对照表如下

各权限的数字对照表：[r]:4;[w]:2;[x]:1;[-]:**0**

![1576571902684](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576571902684-1614758277357.png)

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

所以等一下我们设定权限的变更时，该文件的权限数字就是770啦,变更权限的指令chmod的语法是这样的

```
chmod [-R] xyz 文件或目录
```

选项与参数：

- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
- -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更

上面的 可以表示如下

```shell
chmod  -R 770     档案或目录
```

> 上面说了这么多，我们举例说明一下：

我们进入itcast用户创建文件czbk.txt

```shell
touch as.txt
```

然后切换到root

比如，我们如果要将as.txt这个文件所有的权限都设定启用

![1576463267777](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576463267777-1614758277357.png)

那么命令如下：

```shell
chmod -R 777 as.txt
```

![1576463303277](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576463303277-1614758277357.png)

由此可见，as.txt的属主权限、属组权限、其他权限都发生了改变

由之前的【-rw-rw-r--】变成【-rwxrwxrwx】

> 根据前面的换算我们已经知道如何将一个文件的属主、属组、其他权限换算成数字了，换算成数字后，我们只需要通过chmod命令即可更改文件的权限

#### **2) 符号权限**

还有一个改变权限的方法，就是 符号权限，我们先回顾下之前提到的9个权限

- (1)user     属主权限
- (2)group  属组权限
- (3)others  其他权限

那么我们就可以使用 **u, g, o** 来代表三种身份的权限！

此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看

![1576464280724](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576464280724-1614758277357.png)

如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:

上接上面的例子，如下图

我们将as.txt的权限设置为**-rwxr-xr--**

![1576464462903](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576464462903-1614758277357.png)

执行

```shell
chmod u=rwx,g=rx,o=r  as.txt
```

![1576464626496](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576464626496-1614758277357.png)

 由上图我们发现，as.txt的权限变成了-rwxr-xr--

假如我们要将权限去掉而不改变其他已存在的权限呢？举个例子，比如我要拿掉全部人的可读权限，则

```SHELL
 chmod  a-r as.txt
```

执行如下

![1576464852969](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576464852969-1614758277357.png)

由此可见，as.txt的其他权限都没有了，变成了【---】

## 3.4 综合案例

```
在前面的章节中我们讲解了用户、用户组、文件属主、属组以及权限，知识点比较零散，下面，我们就通过一个简单小案例把这些知识点串联起来
```

**需求：**

比如一个公司的开发团队有三个用户：java、erlang、golang有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限

**1、首先，我们创建三个账户**（切换到root）

```shell
adduser java
adduser erlang
adduser golang
```

执行效果如下

![1576587867858](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576587867858-1614758277357.png)

**2、增加用户组**

```shell
groupadd -g 8888 dev-group
```

执行效果如下

![1576588353612](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588353612-1614758277357.png)

**3、创建公共文件并设置权限**

给文件/tmp/project2019/设置属组为dev-group

```shell
 mkdir /tmp/project2019
 
 chown -R :dev-group /tmp/project2019/
 或者
 chgrp -R dev-group  /tmp/project2019/
```

执行效果如下

![1576588480909](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588480909-1614758277357.png)

**4、将用户添加到组**

```shell
gpasswd -a java    dev-group
gpasswd -a erlang  dev-group
gpasswd -a golang  dev-group
```

执行效果如下

![1576588553969](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588553969-1614758277357.png)

查询dev-group组下所有用户

```shell
 grep 'dev-group' /etc/group
```

执行效果如下

![1576588591503](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588591503-1614758277357.png)

**5、切换到java用户**

切换到java用户看看是否有写入权限

```shell
su java
```

![1576588731114](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588731114-1614758277357.png)

新建文件

在我们上面创建的目录tmp/project2019/下面创建文件

```shell
mkdir java-files-new
```

![1576588941546](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576588941546-1614758277358.png)

由此发现，我们在tmp/project2019/下面创建文件发生了权限不足，我们去查看下tmp/project2019/的文件属性，如下图

我们在/tmp目录下执行

```
ls -l
```

执行效果如下

![1576589157095](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589157095-1614758277358.png)

 我们发现目录project2019的文件属性为【drwxr-xr-x】

根据前面学的知识，我们拆分如下

【d】:文件类型

【rwx】：属主

【r-x】：属组

【r-x】：其他

现在答案就出来了，也就是说我们的属组权限是【r-x】，只有读和执行权限，没有写入权限，那么下面我们就给project2019目录增加写入权限。

**6、增加写入权限**

给project2019目录增加写入权限，执行下面的命令（前面已经学习过了）

记得切换到root下执行

```shell
chmod  -R 770  project2019
```

执行效果如下![1576589467908](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589467908-1614758277358.png)

此时我们发现project2019目录的属组权限变成了【rwx】即可读、可写、可执行

**7、切换用户，继续写入**

```shell
su  java
mkdir java-files-new
ls -l
```

执行效果如下

![1576589641341](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589641341-1614758277358.png)

由此发现，这个时候我们有了写入权限，java-files-new文件被成功写入

那么，其他两个用户golang、erlang也是和java一个组的，他们能不能正常写入呢，我们试试（从root切换过去）

```shell
su
su erlang
mkdir erlang-files-new
==============================
su
su golang
mkdir golang-files-new

ls -l
```

执行效果（erlang新建文件）

![1576589820604](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589820604-1614758277358.png)

执行效果（golanglang新建文件）

![1576589856968](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589856968-1614758277358.png)

查看所有文件

![1576589903617](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576589903617-1614758277358.png)

由此可见，我们组的三个用户都成功创建了文件（拥有了写入权限）

**8、验证结论**

为了验证上面的结论，我们新增一个用户itbeijing

看看能否正常新建文件

```shell
useradd   itbeijing
su itbeijing
mkdir  itbeijing-files-new
```

执行效果如下

![1576590031376](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576590031376-1614758277358.png)

由上图我们发现，我们刚刚新创建的用户在创建文件的时候发现了权限不足。

由此说明用户itbeijing用户的属组和文件的属组不一样，所以没有权限。

## 3.5 总结

在企业级开发过程中，实际操作目录是最经常出现的，对于目录常用命令我们要熟练掌握并能熟练编写
因为Linux是多用户系统，所以权限也是非常核心和重要的，我们要熟练编写权限（属主、属组、其他权限）的常用命令。





# Linux-v10.0-02天-课堂笔记

学习目标

- 能够熟练编写文件相关命令
- 能够熟练编写文件解压缩命令
- 能够熟练编写网络查看简单命令
- 能够熟练编写查看磁盘命令、挂载命令
- 能够知道如何使用命令进行分区、格式化
- 能够熟练使用yum进行查找、安装、卸载软件
- 能够熟练使用rpm进行查找、安装、卸载软件
- 能够熟练编写常用的shell脚本

#  1 Linux文件管理

## 1.1 touch命令

```
在Windows系统中，我们如果想创建一个文本文档或者word文件的时候，通常的做法是
鼠标右键---新建---文本文档，这样的话，我们就成功的创建了一个文件，而在Linux中，我们可以通过字符命令的形式进行创建
```

touch命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。

ls -l 可以显示档案的时间记录

**使用者权限：所有权限用户**

**语法**

```
touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]
```

- **参数说明**：
- a 改变档案的读取时间记录。
- m 改变档案的修改时间记录。
- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
- f 不使用，是为了与其他 unix 系统的相容性而保留。
- r 使用参考档的时间记录，与 --file 的效果一样。
- d 设定时间与日期，可以使用各种不同的格式。
- t 设定档案的时间记录，格式与 date 指令相同。
- --no-create 不会建立新档案。
- --help 列出指令格式。
- --version 列出版本讯息。

**使用 touch 创建一个空文件**

在 Linux 系统上使用 `touch` 命令创建空文件，键入 `touch`，然后输入文件名。如下所示

```shell
touch czbk-devops.txt
```

查看

```shell
ls -l czbk-devops.txt
```

执行效果如下图

![1576640085716](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576640085716.png)

**使用 touch 创建批量空文件**

在实际的开发过程中可能会出现一些情况，我们必须为某些测试创建大量空文件，这可以使用 `touch` 命令轻松实现

```shell
touch czbk-{1..10}.txt
```

在上面的例子中，我们创建了 10 个名为 czbk-1.txt` 到 `czbk-10.txt` 的空文件，你可以根据需要更改名称和数字

执行查看命令

```shell
ls -l
```

执行效果如下

![1576640392259](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576640392259.png)

由上图我们发现，我们通过批量命令创建了10个txt文件

**改变/更新文件访问时间**

假设我们想要改变名为 czbk-devops.txt 文件的访问时间，在 `touch` 命令中使用 `-a` 选项，然后输入文件名。如下所示：

1、我们先 查看下czbk-devops.txt的时间属性

```shell
ls -l czbk-devops.txt 
```

执行效果如下

![1576648168657](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576648168657.png)

我们发现，最后的访问时间是12月 18 11:34

更新时间属性，如下

```shell
touch czbk-devops.txt 
```

执行ls命令查看，如下

```shell
ls -l czbk-devops.txt 
```

![1576648319770](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576648319770.png)

我们发现，访问时间变成了 12月 18 13:50

我们也可以使用stat命令进行查看，如下：

```shell
stat czbk-devops.txt 
```

执行效果如下图

![1576648420787](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576648420787.png)

由上图可知：czbk-devops.txt的文件属性、包含访问时间、更改时间、最近改动时间都显示出来了。

 **关于stat命令：**

**stat命令用于显示inode内容。**

stat以文字的格式来显示inode的内容。

**语法**

```
stat [文件或目录]
```

## 1.2 vi与vim命令

### 1.2.1 vi/vim介绍

```
使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作
```

**1、vi介绍**

vi是 `visual interface`的简称, 是linux中**最经典**的文本编辑器。

- vi的特点
  - 只能是编辑 **文本内容**, 不能对 字体 段落进行排版
  - **不支持鼠标操作**
  - **没有菜单**
  - **只有命令**
- vi编辑器在 **系统管理 服务器管理** 编辑文件时, **其功能永远不是图形界面的编辑器能比拟的**

**2、vim介绍**

**vim**:是从 vi （系统内置命令）发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 

vim 则可以说是程序开发者的一项很好用的工具。

### 1.2.2 vi/vim模式

vi/vim模式主要分为以下三种：

**命令模式**：在Linux终端中输入“vim 文件名”就进入了命令模式,但不能输入文字。
**编辑模式：**在命令模式下按i就会进入编辑模式，此时就可以写入程式，按Esc可回到命令模式。
**末行模式：**在命令模式下按：进入末行模式，左下角会有一个冒号出现，此时可以敲入命令并执行。

下面是三种模式的简单分析图：

![1576653460302](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576653460302.png)

> 上图总结
>
> 上面的三种模式简单总结下就是：
>
> 1、vim  开始进入时是命令模式
>
> 2、按下I的时候会进入编辑模式
>
> 3、按下ESC然后在按下：的时候是末行模式



###  1.2.3 打开和新建文件

```
使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。
```

**使用者权限：当前文件的权限用户**

- 在终端中输入vim在后面跟上 文件名 即可

```
vim txtfile.txt
```

- 如果文件已经存在, 会直接打开该文件
- 如果文件不存在, 保存且退出时 就会新建一个文件

> 注意
>
> 我们通过下面的三种模式切换详细阐述vim的用法

###  1.2.4 三种模式切换

**1、进入命令模式**

上接上面的例子，我们执行下面的命令其实就是进入了命令模式

```shell
vim txtfile.txt
```

执行效果如下图

![1576655123201](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576655123201.png)

**2、进入编辑模式**

上接上面的例子，按i进入插入模式

- 在 vi 中除了常用 `i` 进入**编辑模式** 外, 还提供了一下命令同样可以进入编辑模式

| 命令 | 英文   | 功能                   | 常用   |
| ---- | ------ | ---------------------- | ------ |
| i    | insert | 在当前字符前插入文本   | 常用   |
| I    | insert | 在行首插入文本         | 较常用 |
| a    | append | 在当前字符后添加文本   |        |
| A    | append | 在行末添加文本         | 较常用 |
| o    |        | 在当前行后面插入一空行 | 常用   |
| O    |        | 在当前行前面插入一空行 | 常用   |

上图可以表现为以下形式，如下图

![1576663442969](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576663442969.png)

执行效果如下图

![1576655181144](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576655181144.png)

由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式

我们在里面插入数据，如下图

因为我们是一个空文件，所以使用【I】或者【i】都可以

如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本

![1576655270283](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576655270283.png)

**3、进入末行模式**

编辑模式不能保存文件
必须先推到命令模式
先按Esc键退出到命令模式
然后按小写的**:wq 正常保存退出**

进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图

![1576655879564](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576655879564.png)

然后按小写的**:wq 正常保存退出**

![1576655592207](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576655592207.png)

退出后显示【已写入】

**以下为其他的退出模式：**

:q            当vim进入文件没有对文件内容做任何操作可以按"q"退出

:q!           当vim进入文件对文件内容有操作但不想保存退出

:wq          正常保存退出

:wq!         强行保存退出，只针对与root用户或文件所有人生

> 总结
>
> 三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤
>
> 那么接下来，我们学习下一个命令
>
> 查看刚才新创建的文件

### 1.2.5 文件查看

```
比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看
```

以下5个为文件查看命令，**我们只讲4个常用的命令，head不在赘述**

| 序号 | 命令               | 对应英文    | 作用                             |
| ---- | ------------------ | ----------- | -------------------------------- |
| 01   | cat 文件名         | concatenate | 查看小文件内容                   |
| 02   | less -N 文件名     | less        | **分频** 显示大文件内容          |
| 03   | head -n 文件名     |             | 查看文件的**前一**部分           |
| 04   | tail -n 文件名     |             | 查看文件的**最后**部分           |
| 05   | grep 关键字 文件名 | grep        | 根据**关键词**, 搜索文本文件内容 |

> 总结：
>
> 以上5个命令都可以查询文件的内容，他们的功能如下
>
> 通过 `cat` 会一次显示所有的内容, 适合 **查看内容较少** 的文本文件
>
> `less` 命令适合查看 **内容较多** 的文本文件
>
> 通过 `head` 命令查看文档的前几行内容
>
> 通过 `tail -10f 文件` 命令 查看文档(日志)的后几行内容
>
> 通过 `grep` 命令 搜索存在 **关键字** 的行

#### **1) cat命令**

```
使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的
txt---打开--查看
```

cat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt

**使用者权限：当前文件的权限用户**

**语法格式**

```
cat [-AbeEnstTuv] [--help] [--version] fileName
```

**查看文件名为txtfile.txt的内容**

```shell
cat txtfile.txt
```

执行效果如下图

![1576657358085](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576657358085.png)

**查看文件名为txtfile.txt的内容（加入行号）**

```shell
cat -n txtfile.txt
```

执行效果如下图

![1576657409815](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576657409815.png)

#### 2) grep命令

```
grep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找
grep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程
```

grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。

grep 命令用于查找文件里符合条件的字符串，语法如下：

```
grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
```

**使用者权限：当前文件的权限用户**

我们还是使用上面的txtfile.txt文件，如下图

![1576664862829](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576664862829.png)

> 为了测试效果，我们新增了其他数据
>
> 增加过程不在赘述

1、搜索 **存在关键字【eeee】** 的行的文件

```shell
grep eeee txtfile.txt 
```

执行效果如下

![1576664910366](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576664910366.png)

2、搜索 **存在关键字【eeee】** 的行 且 **显示行号**

```shell
grep -n eeee txtfile.txt 
```

![1576665113269](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576665113269.png)

3、**忽略大小写** 搜索 **存在关键字** 的行

```shell
grep -i EEEE txtfile.txt 
```

执行效果如下

![1576666861596](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576666861596.png)

4、搜索 **不存在关键字** 的行

```shell
grep -v 中国 txtfile.txt 
```

执行效果如下

![1576666928266](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576666928266.png)

**5、查找指定的进程信息（包含grep进程）**

```shell
ps -ef | grep  sshd
```

执行效果如下

![1577095621215](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577095621215.png)

> 说明
>
> 除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程

**6、查找指定的进程信息（不包含grep进程）**

```shell
ps aux | grep sshd | grep -v "grep"
```

执行效果如下

![1577095998308](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577095998308.png)

**7、查找进程个数**

```shell
 ps -ef|grep -c sshd
```

 执行效果如下

![1577096070670](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577096070670.png)

由上图可知sshd的进程个数为4（包含grep进程本身）

#### 3) tail命令

```
tail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现
```

tail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。

**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。

**使用者权限：当前文件的权限用户**

**命令格式：**

```shell
tail [参数] [文件]  
```

**1、要显示 txtfile.txt  文件的最后 3 行，请输入以下命令：**

```shell
tail -3 txtfile.txt 
```

原始文件内容如下

![1576667678964](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576667678964.png)

最后3行内容如下

![1576667701796](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576667701796.png)

**2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令：**

```shell
tail -f txtfile.txt
```

执行效果如下：

![1576667811261](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576667811261.png)

此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。

如果要显示最后4行，命令如下：

```shell
tail -4f txtfile.txt
```

执行效果如下

![1576719306123](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576719306123.png)

**3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾**

```shell
tail  -n +2  txtfile.txt
```

执行效果如下

![1576719057889](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576719057889.png)

**4、显示文件 txtfile.txt的最后 10 个字符:**

```shell
tail -c 45 txtfile.txt
```

执行效果如下

![1576719098586](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576719098586.png)

> 总结
>
> 在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行
>
> 使用tail -nf txtfile.txt
>
> 通常都是在查看日志信息（报错调试时使用）

#### 4）less命令

```
less命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容,  每次只显示一页内容，有点类似我们做分页查询
```

less用于查看文件，但是less 在查看之前不会加载整个文件。

**使用者权限：当前文件的权限用户**

**语法**

```shell
less [参数] 文件 
```

1、查看txtfile.txt文件

```shell
less txtfile.txt
```

执行效果如下

![1576720622842](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576720622842.png)

2、查看命令历史使用记录并通过less分页显示

```shell
[itcast@localhost ~]$  history | less
    1  ifconfig
    2  reboot
    3  ifconfig
    4  reboot
    5  ifconfig
    6  su root
    7  ifconfig
    8  ping  www.baidu.com
    9  \
   10  ifconfig
   11  date
   12  hwclock --systohc
   13  su root
   
   ......略
```

我们输入【j】可以前进行

​        输入【k】可以后退行

​        输入【G】可以 移动到最后一行

​	    输入【g】可以移动到第一行

​        输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页)

​        输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页)

**其他命令**

1.全屏导航

- ctrl + F - 向前移动一屏
- ctrl + B - 向后移动一屏
- ctrl + D - 向前移动半屏
- ctrl + U - 向后移动半屏

2.单行导航

- j - 向前移动一行
- k - 向后移动一行

3.其它导航

- G - 移动到最后一行
- g - 移动到第一行
- q / ZZ - 退出 less 命令

### 1.2.6  vim定位行

```
在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况
例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置
这个时候,可以使用以下命令打开文件
```

由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下：

```shell
vim txtfile.txt +6
```

执行效果如下图

![1576659165723](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576659165723.png)

### **1.2.7 异常处理**

- 如果 vim异常退出, 在磁盘上可能会保存有 交换文件
- 下次再使用 vim 编辑文件时, 会看到以下屏幕信息,

![1576658330514](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576658330514.png)

解决方案：

将后缀名为.swp的文件删除即可恢复

![1576658480811](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576658480811.png)

再次编辑文件不在出现提示警告！



### 1.2.8 操作扩展

要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标
编辑操作命令 能够和移动命令一起使用

**1) 上 下 左 右**

![1558278451153](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1558278451153.png)

| 命令 | 功能 | 手指   |
| ---- | ---- | ------ |
| h    | 向左 | 食指   |
| j    | 向下 | 食指   |
| k    | 向上 | 中指   |
| l    | 向右 | 无名指 |

也可以使用键盘上的上下左右箭头，这个更有方向感。

**2) 行内移动**

| 命令 | 英文 | 功能                           |
| ---- | ---- | ------------------------------ |
| w    | word | 向后移动一个单词               |
| b    | back | 向前移动一个单词               |
| 0    |      | 行首                           |
| ^    |      | 行首, 第一个不是空白字符的位置 |
| $    |      | 行尾                           |

**3) 行数移动**

| 命令   | 英文 | 功能                  |
| ------ | ---- | --------------------- |
| gg     | go   | 文件顶部              |
| G      | go   | 文件末尾              |
| 数字gg | go   | 移动到 数字 对应行数  |
| 数字G  | go   | 移动到 数字 对应行数  |
| : 数字 |      | 移动到数字对应的 行数 |

**4) 屏幕移动**

| 命令     | 英文    | 功能     |
| -------- | ------- | -------- |
| Ctrl + b | back    | 向上翻页 |
| Ctrl + f | forward | 向下翻页 |
| H        | Head    | 屏幕顶部 |
| M        | Middle  | 屏幕中间 |
| L        | Low     | 屏幕底部 |

**5) 选中文本(可视模式)**

- 学习 复制 命令前, 应该先学会 **怎么样选中 要复制的代码**
- 在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 **可视模式**
- vi/vim 中提供了 **三种** 可视模式, 可以方便程序员的选择 **选中文本的方式**
- 按 ESC 可以放弃选中, 返回到 **命令模式**

| 命令     | 模式       | 功能                               |
| -------- | ---------- | ---------------------------------- |
| v        | 可视模式   | 从光标位置开始按照正常模式选择文本 |
| V        | 可视化模式 | 选中光标经过的完整行               |
| Ctrl + v | 可是块模式 | 垂直方向选中文本                   |

**6) 撤销和恢复撤销(保命指令)**

在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作

| 命令     | 英文  | 功能                     |
| -------- | ----- | ------------------------ |
| u        | undo  | 撤销上次的命令(ctrl + z) |
| Ctrl + r | uredo | 恢复撤销的命令           |

**7) 删除文本**

| 命令        | 英文   | 功能                              |
| ----------- | ------ | --------------------------------- |
| x           | cut    | 删除光标所在的字符,或者选中的文字 |
| d(移动命令) | delete | 删除移动命令对应的内容            |
| dd          | delete | 删除光标所在行, 可以删除多行      |
| D           | delete | 删除至行尾                        |

提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本

删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):

| 命令 | 作用                        |
| ---- | --------------------------- |
| dw   | 从光标位置删除到单词末尾    |
| d}   | 从光标位置删除到段落末尾    |
| ndd  | 从光标位置向下连续删除 n 行 |

**8) 复制和剪切**

- vi/vim 中提供有一个 被复制文本的缓冲区
  - 复制 命令会将选中的文字保存在缓冲区
  - 删除 命令删除的文字会被保存在缓冲区
  - 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置

| 命令        | 英文   | 功能                       |
| ----------- | ------ | -------------------------- |
| yy          | copy   | 复制行                     |
| d(剪切命令) | delete | 剪切                       |
| dd(剪切)    | delete | 剪切一行, 可以 ndd 剪切n行 |
| p           | paste  | 粘贴                       |

提示:

- 命令 d 、x 类似于图形界面的 **剪切操作**  -- ctrl + x
- 命令 y 类似于 图形界面的 **复制操作** -- Ctrl + 
- 命令 p 类似于图形界面的 **粘贴操作** -- Ctrl + v
- vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换.

注意

- vi中的 **文本缓冲区** 和 系统的 **剪切板** 不是同一个
- 所以在其他软件中使用 `Ctrl + C` 复制的内容, 不能再 `vi` 中通过 `p` 命令粘贴
- 可以在 **编辑模式** 下使用 **鼠标右键粘贴**

**9) 替换**

| 命令 | 英文    | 功能                   | 工作模式 |
| ---- | ------- | ---------------------- | -------- |
| r    | replace | 替换当前字符           | 命令模式 |
| R    | replace | 替换当前行光标后的字符 | 替换模式 |

- `R` 命令可以进入 **替换模式**, 替换完成后, 按下`ESC` , 按下 `ESC` 可以回到 **命令模式**
- **替换命令** 的作用就是不用进入 **编辑模式**, 对文件进行 **轻量级的修改**

**10) 缩排和重复执行**

| 命令 | 功能         |
| ---- | ------------ |
| >>   | 向右增加缩进 |
| <<   | 向左减少缩进 |
| .    | 重复上次命令 |

- **缩进命令** 在开发程序时, **统一增加代码的缩进** 比较有用!
  - 一次性 **在选中代码前增加 4 个空格,**  就叫做 **增加缩进**
  - 一次性 **在选中代码前删除 4 个空格**,  就叫做 **较少缩进**
- 在 **可视模式** 下, 缩排命令 主需要使用 一个 `>` 或者 `<`

在程序中, **缩进** 通常用来表示代码的归属关系

- **前面空格越少, 代码的级别越高**
- **前面空格越多, 代码的级别越低**

**11) 查找**

常规查找

| 命令 | 功能    |
| ---- | ------- |
| /str | 查找str |

- 查找到指定内容之后, 使用 `Next` 查找下一个出现的位置
  - `n` : 查找下一个
  - `N` : 查找上一个
- 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可

- 单词快速匹配

| 命令 | 功能                     |
| ---- | ------------------------ |
| *    | 向后查找当前光标所在单词 |
| #    | 向前查找当前光标所在单词 |

- 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过

**12) 查找并替换**

- 在 `vi/vim` 中查找和替换命令需要在 **末行模式** 下执行
- 记忆命令格式

```
:%s///g
```

1)  全局替换

- 一次向 替换文件中的 所有出现的旧文本

- 命令格式如下

  ```
  :%s/旧文本/新文本/g
  ```

2) 可视区域替换

- **先选中** 要替换文字的 **范围**
- 命令格式如下

```
:s/旧文本/新文本/g
```

3) 确认替换：

c confirm 确认

- 如果把末尾的 `g` 改成 `gc`  在替换的时候, 会有提示! 推荐使用

- 命令格式如下

  ```
  :%s/旧文本/新文本/gc
  ```

1. `y` - `yes` 替换
2. `n` - `no` 不替换
3. `a` - `all` 替换所有
4. `q` -`quit` 退出替换
5. `l` - `last` 最后一个, 并把光标移动到行首
6. `^E` 向下滚屏
7. `^Y` 向上滚屏

## 1.3 echo 命令

```
echo命令有点类似于我们在java se阶段学习的 System.out.print("hello")
但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样
```

**使用者权限：所有用户**

- `echo string` 将字符串输出到控制台 ,  通常和 **重定向** 联合使用

```
echo hello world

# 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号
echo "hello world"
```

**6.3 重定向 `>`(覆盖) 和 `>>` (追加)** 

![1558435686066](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1558435686066-1576721493121.png)

- 默认情况下 **命令的结果** 输出到 **控制台**
- 通过 **重定向** 可以将结果 **输出到文件**

**6.2.3 实现**

- **第一步: 将命令的成功结果 覆盖 指定文件内容**

```
 echo  传智博客 >czbk-txt.txt
```

执行结果如下（czbk-txt.txt文件如果没有会自动创建）

![1576721910460](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576721910460.png)

| 命令          | 作用                               |
| ------------- | ---------------------------------- |
| 结果 > 文件名 | `>` 表示输出, 会覆盖文件的原有内容 |

- ##### 第二步: 将**命令的成功结果** **追加**  指定文件的后面

```
echo  黑马程序员 >> czbk-txt.txt
```

执行结果如下

![1576721980097](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576721980097.png)

| 命令           | 作用                                        |
| -------------- | ------------------------------------------- |
| 命令 >> 文件名 | `>>` 表示追加, 会将内容追加到已有文件的末尾 |

- ##### 第三步: 将**命令的失败结果** **追加** 指定文件的后面

```
cat 不存在的目录  &>>  error.log
```

执行效果如下

![1576722167942](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576722167942.png)

| 命令             | 作用                                   |
| ---------------- | -------------------------------------- |
| 命令  `&>>` 文件 | `&>>` 表示不区分错误类型 都放到 日志中 |

> 总结
>
> - 通过 `命令 > 文件`  将**命令的成功结果** **覆盖** 指定文件内容
> - 通过 `命令 >> 文件`   将**命令的成功结果** **追加**  指定文件的后面
> - 通过 `命令 &>> 文件` 将 **命令的失败结果** **追加** 指定文件的后面

## 1.4 awk命令

AWK是一种处理文本文件的语言，是一个强大的文本分析工具。

之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。

**具体语法如下**

```shell
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

**1、数据准备：czbk-txt.txt文本内容如下：**

```shell
zhangsan 68 99 26
lisi 98 66 96
wangwu 38 33 86
zhaoliu 78 44 36
maq 88 22 66
zhouba 98 44 46
```

 **2、搜索含有 zhang  和 li 的学生成绩：**

```shell
cat czbk-txt.txt | awk '/zhang|li/'
```

执行效果如下

![1577178031588](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577178031588.png)

**指定分割符, 根据下标显示内容**

| 命令                                        | 含义                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| awk   -F  ','    '{print $1, $2, $3}'  文件 | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |

选项

| 选项       | 英文            | 含义                     |
| ---------- | --------------- | ------------------------ |
| `-F ','`   | field-separator | 使用 **指定字符** 分割   |
| `$ + 数字` |                 | 获取**第几段**内容       |
| `$0`       |                 | 获取 **当前行** 内容     |
| `NF`       | field           | 表示当前行共有多少个字段 |
| `$NF`      |                 | 代表 最后一个字段        |
| `$(NF-1)`  |                 | 代表 倒数第二个字段      |
| `NR`       |                 | 代表 处理的是第几行      |

```
# 查看文档内容
cat czbk-txt.txt 
#直接输出
cat score.txt | awk -F ' ' '{print $1,$2,$3}'
```

执行效果如下

![1577178523300](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577178523300.png)

**指定分割符, 根据下标显示内容**

| 命令                                                    | 含义                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| awk   -F  ' '    '{OFS="==="}{print $1, $2, $3}'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |

选项

| 选项         | 英文                   | 含义                     |
| ------------ | ---------------------- | ------------------------ |
| `OFS="字符"` | output field separator | 向外输出时的段分割字符串 |

| 转义序列 | 含义   |
| -------- | ------ |
| \b       | 退格   |
| \f       | 换页   |
| \n       | 换行   |
| \r       | 回车   |
| \t       | 制表符 |

```
# 按照 === 进行分割, 打印 第一段 第二段 第三段
cat  czbk-txt.txt | awk -F ' ' '{OFS="==="}{print $1,$2,$3}'
# 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段
cat czbk-txt.txt| awk -F ' ' '{OFS="\t"}{print $1,$2,$3}'
```

执行效果如下

![1577178563336](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577178563336.png)

![1577179227699](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577179227699.png)

**调用 awk 提供的函数**

| 命令                                           | 含义                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| awk   -F  ','    '{print  toupper($2)}'  1.txt | 操作1.txt文件,  根据 逗号 分割, 打印 第一段 第二段 第三段 内容 |

常用函数如下:

| 函数名    | 含义   | 作用           |
| --------- | ------ | -------------- |
| toupper() | upper  | 字符 转成 大写 |
| tolower() | lower  | 字符 转成小写  |
| length()  | length | 返回 字符长度  |

```
# 打印第一段内容
 cat czbk-txt.txt | awk -F ' ' '{print $1}'
# 将第一段内容转成大写 且 显示 
 cat czbk-txt.txt | awk -F ' ' '{print toupper($1)}'
```

执行效果如下

![1577180402362](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577180402362.png)

**求指定学科平均分**

| 命令                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| awk 'BEGIN{初始化操作}{每行都执行} END{结束时操作}'   文件名 | BEGIN{ 这里面放的是执行前的语句 }<br />{这里面放的是处理每一行时要执行的语句}<br />END {这里面放的是处理完所有的行后要执行的语句 } |

**查看czbk-txt.txt 文件内容**

```shell
cat czbk-txt.txt 
```

执行效果如下

![1577180698120](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577180698120.png)

**查看总分**

注意：这里计算的是第4列的总分

```shell
cat czbk-txt.txt| awk -F ' ' 'BEGIN{}{total=total+$4} END{print total}'
```

执行效果如下

![1577180583110](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577180583110.png)

**查看总分, 总人数**

注意：这里计算的是第4列的

```shell
cat czbk-txt.txt| awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR}'
```

执行效果如下

![1577180635136](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577180635136.png)

**查看总分, 总人数, 平均分**

注意：这里计算的是第4列的

```shell
 cat czbk-txt.txt | awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}'
```

执行效果如下

![1577180660454](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577180660454.png)

> 总结
>
> awk在使用过程中主要用作分析
>
> 简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理

## 1.5  软连接

```
软连接其实就类似于我们在Windows中的【快捷方式】
```

- 在Linux**文件名** 和 **内容** 是两个文件, 分开的!![1558439106175](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1558439106175.png)



- 创建软链接的原理, 如下![1558439158250](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1558439158250.png)

  为什么有软连接？

  因为 某些文件和目录 的 **路径很深**, 所以 需要增加 **软链接(快捷方式)**

**使用者权限：所有用户**

**语法如下:**

| 命令                                      | 英文 | 作用                                         |
| ----------------------------------------- | ---- | -------------------------------------------- |
| ln **-s**  目标文件绝对路径  快捷方式路径 | link | 给目标文件增加一个软链接, 通俗讲就是快捷方式 |

**给home/itcast/txtfile.txt文件增加软连接**

```shell
 ln  -s /home/itcast/txtfile.txt    czbk-txt
```

上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到

czbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的

如下图

![1576723058556](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576723058556.png)

> 总结
>
> 通过 `ln -s 源文件的绝对路径 其实就是给**目标文件** 增加 **快捷方式**

## 1.6 find查找

```
引子
find命令类似与在Windows中全局查找（如下图）
```

![1576828863833](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576828863833.png)

**find概念**

find命令用来在指定目录下查找文件。

任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

**语法**

```shell
find <指定目录> <指定条件> <指定内容>
```

**1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来** 

```shell
find . -name "*.gz"
```

执行效果如下图

![1576829221486](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576829221486.png)



**2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来**

```shell
find . -ctime -1
```

执行效果如下

![1576829352063](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576829352063.png)

**3、全局搜索czbk**

/代表是全盘搜索,也可以指定目录搜索 

```shell
 find / -name  'czbk'
```

执行效果如下

![1576829929308](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576829929308.png)

## 1.7 read命令

> 注意：
>
> read命令属于文件范畴的命令
>
> 在下面的演示中，会涉及到shell，shell章节在最后一章
>
> 建议：讲解shell的时候在回过来说下read命令的语法
>
> 我们在综合案例中也会降到read

```
引子：
read命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互，
```

read命令用于从标准输入读取数值。

read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。

**语法**

```
read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
```

**1、简单读取**

```shell
#!/bin/bash
echo "请您输入网站名: "  
#读取从键盘的输入  
read website  
echo "你输入的网站名是 $website"  
exit 0  #退出
```

执行效果如下

![1577409765115](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577409765115.png)



**3、读取文件**

每次调用 read 命令都会读取文件中的 "一行" 文本。当文件没有可读的行时，read 命令将以非零状态退出。

我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。

测试文件 test.txt 内容如下：

```
AAAAAAAAAAAAAAAAAAAAAA
BBBBBBBBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCCCCCCCC
DDDDDDDDDDDDDDDDDDDDDD
================传智播客
```

脚本如下，可以将脚本放到xxx.sh中进行执行

```shell
#!/bin/bash
count=1
cat test.txt | while read line      
# cat 命令的输出作为read命令的输入,read读到>的值放在line中
do
   echo "Line $count:$line"
   count=$[ $count + 1 ]          # 注意中括号中的空格。
done
echo "finish"
exit 0
```

执行效果如下

![1577410272633](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577410272633.png)

> 总结
>
> 由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件

## 1.8 总结

文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。

# 2 Linux备份压缩

```
在Windows中我们对于一个大文件进行压缩的时候，通常会使用第三方工具，比如360压缩、快压等工具，把一个文件压缩成.zip格式的压缩文件；而在Linux中我们也可以通过各种命令实现压缩的功能。
```

## **2.1 gzip命令**

```
压缩/解压缩文件，不能压缩目录
windows下接触的压缩文件大多是.rar，.7z格式，Linux下，不能识别这种格式。
.zip格式的文件在Windows和Linux下都能使用。
压缩文件，能节省磁盘空间，传输时能节省网络带宽
```

gzip命令用于压缩文件。

gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名

**使用者权限：所有用户**

**语法**

```shell
gzip[参数][文件或者目录]
```

**1、压缩目录下的所有文件**

数据准备，新建一个目录，里面随便新建4个文件

```shell
mkdir  gzipTest
cd gzipTest/
touch  001
touch  002
touch  003
touch  004
```

执行效果如下

![1576736152636](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576736152636.png)

**1、压缩目录下的所有文件**

```shell
gzip * 
```

![1576736179025](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576736179025.png)

**2、 列出详细的信息**

解压文件并列出详细信息

```shell
gzip -dv *
```

执行效果如下图

![1576736286406](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576736286406.png)



## 2.2 gunzip命令

```
gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件
```

gunzip命令用于解压文件。

**语法**

```
gunzip[参数][文件或者目录]
```

```shell
gunzip 001.gz 
```

执行效果如下图

![1576738711718](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576738711718.png)

001为解压后的文件

## 2.3 tar命令

```
tar的主要功能是打包、压缩和解压文件。

tar本身不具有压缩功能。他是调用压缩功能实现的 。
```

**使用者权限：所有用户**

**语法**

```shell
tar[必要参数][选择参数][文件] 
```

**1、将 txtfile.txt文件打包（仅打包，不压缩）**

txtfile.txt文件为上面章节的例子

```shell
tar -cvf txt.tar txtfile.txt 
```

执行效果如下

![1576726937758](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576726937758.png)

 **2、将 txtfile.txt文件打包压缩（打包压缩（gzip））**

```shell
tar -zcvf txt.tar.gz txtfile.txt 
```

执行效果如下

![1576727107465](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576727107465.png)

>  总结
>
>  参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包

**3、查看tar中有哪些文件**

```shell
tar -ztvf txt.tar.gz
```

执行效果如下

![1576734505587](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576734505587.png)

压缩包中的文件有txtfile.txt

**4、将tar 包解压缩**

```shell
1.新建目录
 mkdir ysFiles
2.复制
 cp txt.tar.gz ./ysFiles/
3.解压缩
 tar -zxvf /home/itcast/ysFiles/txt.tar.gz
```

解压后的文件如下

![1576735062585](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576735062585.png)

## 2.4 zip命令

```
引子
zip命令就完全的相当于在Windows下面选中文件右键进行压缩了
```

zip命令用于压缩文件。

zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有".zip"扩展名的压缩文件。

**使用者权限：所有用户**

**语法**

```
zip[必要参数][选择参数][文件] 
```

将上面/home/itcast/gzipTest 这个目录下所有文件和文件夹打包为当前目录下的 zFiles.zip：

```shell
1.在目录下新建一个005目录
mkdir 005
```

执行效果如下

![1576736751949](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576736751949.png)

开始压缩

```shell
2.压缩
zip -q -r zFiles.zip *
```

执行效果如下

![1576736844251](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576736844251.png)zFiles.zip文件就是我们刚刚压缩后的文件

## 2.5 unzip命令

```
引子
unzip命令就完全的相当于在Windows下面选中文件右键进行解压缩了
```

Linux unzip命令用于解压缩zip文件

unzip为.zip压缩文件的解压缩程序

**使用者权限：所有用户**

**语法**

```
unzip[必要参数][选择参数][文件] 
```

**参数**：

上接上面的zip的例子

**1、查看压缩文件中包含的文件：**

```shell
 unzip -l zFiles.zip
```

![1576737168412](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576737168412.png)

包含了压缩文件里面文件的详细信息

文件大小  日期 时间  文件名称

总数量和总大小

**2、如果要把文件解压到指定的目录下，需要用到-d参数**

```shell
1.新建目录
unFiles
2.解压缩
unzip -d ./unFiles zFiles.zip
```

执行效果如下

![1576737722160](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576737722160.png)

 查看解压后的文件，如下图

![1576737744650](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576737744650.png)



## 2.6 bzip2命令

```
引子
".bz2"格式是 Linux 的另一种压缩格式，从理论上来讲，".bz2"格式的算法更先进、压缩比更好；而 咱们上面学到的".gz"格式相对来讲时间更快
在使用过程中可以根据需求自由选择
```

bzip2命令是.bz2文件的压缩程序。

bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。	

**使用者权限：所有用户**

**语法**

```
bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]
```

**1、压缩文件**

```
1.创建目录
 mkdir  bzFiles
 cd ./bzFiles/
2.创建文件
touch 001
3.压缩
bzip2 001
ll
```

执行效果如下

![1576742060052](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576742060052.png)

如上图001.bz2就是压缩后的文件

## **2.7 bunzip2命令**

```
引子
Linux bunzip2命令是.bz2文件的解压缩程序。
```

**使用者权限：所有用户**

**语法**：

```shell
bunzip2 [-fkLsvV][.bz2压缩文件]
```

**参数**：

**解压.bz2文件**

```shell
bunzip2 -v 001.bz2 
```

执行效果如下图

![1576744907366](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576744907366.png)

001文件即是被解压后的

## 2.8 总结

gz：由gzip压缩工具压缩的文件。

.bz2：由bzip2压缩工具压缩的文件。

.tar：由tar打包程序打包的文件（tar没有压缩功能，只是把一个 目录合并成一个文件）

.tar.gz：可理解为先由tar打包，再由gz压缩。

.zip:可理解为由zip压缩工具直接压缩

# 3 网络与磁盘管理

> Tips:
>
> 重点讲解内容

## **3.1 网络命令**

### 3.1.1 ifconfig命令

![image-20210304204343216](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304204343216.png)

```
引子：

ifconfig命令有点类似于Windows的ipconfig命令
```

ifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring

 ifconfig命令用于显示或设置网络设备。

ifconfig可设置网络设备的状态，或是显示目前的设置。

**使用者权限：所有（设置级别的需要管理员）用户**

**语法**

```
ifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O地址>][irq<IRQ地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]
```

**1、显示激活的网卡信息**

```
ifconfig
```

执行效果如下

![1576749039798](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576749039798.png)

![1576749055869](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576749055869.png)

**ens33（有的是eth0）**表示第一块网卡。

表示ens33网卡的 IP地址是 192.168.23.129，广播地址，broadcast 192.168.23.255，掩码地址netmask:255.255.255.0 ，inet6对应的是ipv6

**ens37** 表示第二块网卡

**lo** 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 

启动关闭指定网卡

**virbr0**是一种虚拟网络接口

**2、关闭网卡（需要切换到管理员账户）**

```shell
 ifconfig ens37 down
```

执行效果如下

![1576748850255](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576748850255.png)

**3、启用网卡（需要切换到管理员账户）**

```shell
ifconfig ens37 up
```

 执行效果如下

![1576748937884](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576748937884.png)

**4、配置ip信息**

```shell
// 配置ip地址
ifconfig ens37 192.168.23.199
// 配置ip地址和子网掩码
ifconfig ens37 192.168.23.133 netmask 255.255.255.0
```

执行效果如下，配置ip地址：

![1576749864267](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576749864267.png)

查看ip，如下图

![1576749896757](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576749896757.png)

配置ip地址和子网掩码，执行效果如下图

![1576749957171](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576749957171.png)

这样的话我们就可以通过命令的方式设置网卡的网络信息了。

### 3.1.2 ping命令

![image-20210304204649751](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304204649751.png)



```
等价于Windows的ping命令
```

ping命令用于检测主机。

执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。

**使用者权限：所有用户**

**语法**

```shell
ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]
```

**1、检测是否与主机连通**

```shell
 ping www.baidu.com
```

执行效果如下

![1576750258293](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576750258293.png)	

icmp_seq：ping序列，从1开始

ttl:IP生存时间值

time: 响应时间,数值越小，联通速度越快

**2、指定接收包的次数**

和上面不同的是：收到两次包后，自动退出

```shell
ping -c 2 www.baidu.com
```

执行效果如下图

![1576750967595](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576750967595.png)

> 总结：
>
> ping命令也是我们在开发过程中常用到的命令
>
> 通常使用  ping  xxx.xxx.xxx.xxx命令进行检测本地与目标机器是否连通

### 3.1.3 netstat命令

![image-20210304204839048](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304204839048.png)



```
利用netstat指令可让你得知整个Linux系统的网络情况
```

netstat命令用于显示网络状态。

**使用者权限：所有用户**

**语法**

```
netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]
```

**1、显示详细的连接状况**

```shell
netstat -a
```

执行效果如下

![1576751379320](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576751379320.png)

比如上面的【0 0.0.0.0:ssh】它是远程终端连接Linux的ssh服务，默认使用了22端口，它的状态【State】是处于监听状态，属于正常。

**2、显示网卡列表**

```shell
netstat -i
```

执行效果如下

![1576751502980](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576751502980.png)

上图显示的是我们在介绍【ifconfig】命令的时候看到的网卡信息

## 3.2 磁盘命令

### **3.2.1 lsblk命令**



![image-20210304212303621](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304212303621.png)



![image-20210304212620679](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304212620679.png)



```
使用lsblk命令可以以tree的形式展示所有设备的信息
```

lsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。

**语法格式：**lsblk [参数]

**使用者权限：所有用户**

**1、lsblk命令默认情况下将以树状列出所有块设备：**

```shell
lsblk
```

执行效果如下图

![1576827840642](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576827840642.png)

NAME : 这是块设备名。

MAJ:MIN : 本栏显示主要和次要设备号。

RM : 本栏显示设备是否可移动设备。注意，在上面设备sr0的RM值等于1，这说明他们是可移动设备。

SIZE : 本栏列出设备的容量大小信息。

RO : 该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。

TYPE :本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。

MOUNTPOINT : 本栏指出设备挂载的挂载点。

**2、默认选项不会列出所有空设备：**

```shell
lsblk -f
```

执行效果如下图

![1576828112552](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576828112552.png)

NAME表示设备名称

FSTYPE表示文件类型

LABEL表示设备标签

UUID设备编号

MOUNTPOINT表示设备的挂载点

> 注意
>
> 我们学习这个命令主要是在下面将要学习的fdisk分区中会经常使用到

### 3.2.2 df命令



![image-20210304212651757](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304212651757.png)



![image-20210304212938983](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304212938983.png)



```
引子（如下图）：
Linux的df命令类似于在Windows中的【计算机】--【管理】--【磁盘管理】菜单对磁盘的统计情况查看
```

![1576751996364](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576751996364.png)

 df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。

**使用者权限：所有用户**

**语法**

```
df [选项]... [FILE]...
```

**1、显示磁盘使用情况统计情况**

```
df  
```

执行效果如下图

![1576752158168](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576752158168.png)

第一列指定文件系统的名称

第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总容量。

已用和可用列分别指定的容量。

最后一个已用列指定使用的容量的百分比

最后一栏指定的文件系统的挂载点。

**2、df命令也可以显示磁盘使用的文件系统信息**

比如我们df下之前创建过的目录gzipTest的使用情况

```
df  gzipTest/
```

执行效果如下图

![1576752596414](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576752596414.png)

**3、df显示所有的信息**

```
df --total 
```

执行效果如下图

![1576752719226](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576752719226.png)

我们看到输出的末尾，包含一个额外的行，显示总的每一列。

 4、df换算后显示

```shell
df -h 
```

执行效果如下图

![1576752819456](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576752819456.png)

我们可以看到输出显示的数字形式的'G'（千兆字节），"M"（兆字节）和"K"（千字节）。

这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的"容量"。

### 3.2.3 mount命令



![image-20210304213238465](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304213238465.png)



![image-20210304213400136](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304213400136.png)



![image-20210304214057965](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304214057965.png)





```
在Linux当中所有的存储设备如u盘、光盘、硬盘等，都必须挂载之后才能正常使用。

其实挂载可以理解为Windows当中的分配盘符（重要），只不过windows当中是以英文字母ABCD等作为盘符，而linux是拿系统目录作为盘符，当然linux当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载
```

 mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。

**挂载概念**

在安装linux系统时设立的各个分区，如根分区、/boot分区等都是自动挂载的，也就是说不需要我们人为操作，开机就会自动挂载。但是光盘、u盘等存储设备如果需要使用，就必须人为的进行挂载。

其实我们在windows下插入U盘也是需要挂载(分配盘符)的，只不过windows下分配盘符是自动的

Linux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。

**注意：“挂载点”的目录需要以下几个要求：**

（1）目录事先存在，可以用mkdir命令新建目录；

（2）挂载点目录不可被其他进程使用到；

（3）挂载点下原有文件将被隐藏。

**使用者权限：所有用户，设置级别的需要管理员**

**语法**

```
mount [-hV]
mount -a [-fFnrsvw] [-t vfstype]
mount [-fnrsvw] [-o options [,...]] device | dir
mount [-fnrsvw] [-t vfstype] [-o options] device dir
```

需求:
比如现在我们要通过挂载的方式查看Linux CD/DVD光驱里面的内容

**1、CD/DVD设置**

进入【虚拟机】--【设置】

![1576805605263](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576805605263.png)



设置CD/DVD的内容，我们这里使用的是F:\CentOS-7-x86_64-DVD-1810.iso

![1576805634085](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576805634085.png)

查看F:\CentOS-7-x86_64-DVD-1810.iso；里面的内容

![1576805690039](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576805690039.png)



**2、创建挂载点**

注意：一般用户无法挂载cdrom,只有root用户才可以操作

我们切换到root下创建一个挂载点（其实就是创建一个目录）

```shell
mkdir  -p mnt/cdrom
```

**3、开始挂载**

通过挂载点的方式查看上面的【ISO文件内容】

```shell
mount -t auto /dev/cdrom /mnt/cdrom
```

执行效果如下

![1576807195774](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576807195774.png)

表示挂载成功

**4、查看挂载点内容**

```shell
ls -l -a ./mnt/cdrom/
```

执行效果如下图

![1576807395970](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576807395970.png)

如上图所示，我们通过挂载点查看CD/DVD的文件个数是14个，和上面的【ISO文件内容】个数一致。

**5、卸载cdrom**

在前面我们将CD/DVD挂载到了文件系统，如果我们不用了，就可以将其卸载掉

```
umount ./mnt/cdrom/
```

执行效果如下图

![1576807774194](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576807774194.png)

我们发现卸载后，通过挂载点就无法查看CD/DVD里面的数据了。

## 3.3 总结

关于挂载：用户**不能**直接访问 硬件设备需要将硬件设备 **挂载** 到 系统目录上,  才可以让用户访问。

# 4 shell与安装

> tips
>
> 重点讲解内容

## 4.1 yum使用



![image-20210304215814007](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304215814007.png)

```
引子：
yum类似于开发工具idea、eclipse中的在线插件安装商店
我们输入一个将要安装的插件名字，进行搜索、安装的过程。
```

**yum概念**

yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。

yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。

**yum原理**

![1576833281476](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576833281476.png)

> **注意：必须联网**
>
> 不同的服务通过yum命令连接远程yum源进行查找、下载、安装

**使用者权限：管理员**

**语法**

```shell
yum [options] [command] [package ...]
```

- **options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。
- **command：**要进行的操作。
- **package**操作的对象。

------

**yum常用命令**

- 1.列出所有可更新的软件清单命令：yum check-update
- 2.更新所有软件命令：yum update
- 3.仅安装指定的软件命令：yum install <package_name>
- 4.仅更新指定的软件命令：yum update <package_name>
- 5.列出所有可安裝的软件清单命令：yum list
- 6.删除软件包命令：yum remove <package_name>
- 7.查找软件包 命令：yum search <keyword>
- 8.清除缓存命令:
  - yum clean packages: 清除缓存目录下的软件包
  - yum clean headers: 清除缓存目录下的 headers
  - yum clean oldheaders: 清除缓存目录下旧的 headers
  - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers

### **4.1.1 安装tree**

```shell
yum -y install tree   //y当安装过程提示选择全部为"yes"
```

执行效果如下

注意：第一次在itcast用户执行的时候

提示我们【需要管理员权限】

![1576554600128](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576554600128.png)

![1576554617660](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576554617660.png)

安装完执行tree命令

```shell
tree
```

![1576832663328](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576832663328.png)

### **4.1.2 移除tree**

```shell
yum remove  tree
```

执行效果如下

![1576832810922](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576832810922.png)

此时，我们在执行tree命令

```shell
tree
```

执行效果如下

![1576832843434](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576832843434.png)

如上图，由于我们移除了tree，在执行tree命令的时候发现找不到这个命令了。

### **4.1.3 yum查找**

利用 yum 的功能，找出以 tom 为开头的软件名称有哪些

```shell
yum list tom*
```

执行效果如下

![1576832953119](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576832953119.png)

### 4.1.4 yum源



![image-20210304220320486](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210304220320486.png)



**概述**

yum需要一个yum库，也就是yum源。

简单的说，我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源，所以yum源就是软件安装包来源 

**yum源分类**

目前，yum默认使用的是CentOS的yum源，如下

  ![1576834523252](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576834523252.png)

![1576834556997](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576834556997.png)

目前，国内有很多不错的yum源，比如阿里、网易、搜狐等

**安装阿里yum源**

因为默认的yum源服务器在国外，我们在安装软件的时候会受到速度的影响，所以安装国内yum源在下载的时候速度、稳定性会比国外的好很多。

**1) 安装wget**

```shell
yum install -y wget
```

 执行效果如下

![1576834799803](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576834799803.png)

![1576834824250](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576834824250.png)

安装成功。

**2) 备份/etc/yum.repos.d/CentOS-Base.repo文件**

```shell
cd /etc/yum.repos.d/
mv CentOS-Base.repo CentOS-Base.repo.back
```

执行效果如下图

![1576834936907](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576834936907.png)

**3) 下载阿里云的Centos-7.repo文件**

```shell
wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
```

> 注意
>
> 上面的url中要卸载Centos-7.repo；而不是Centos-6.repo

 执行效果如下图

![1576837935001](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576837935001.png)

查看下载的阿里云的Centos-6.repo文件

```shell
cat CentOS-Base.repo
```

执行效果如下

```SHELL
# CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the 
# remarked out baseurl= line instead.
#
#
 
[base]
name=CentOS-$releasever - Base - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
 
#released updates 
[updates]
name=CentOS-$releasever - Updates - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
 
#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
 
#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
 
#contrib - packages by Centos Users
[contrib]
name=CentOS-$releasever - Contrib - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
```

如上面的命令，之前是【CentOS】，现在是【aliyun】

**4) 重新加载yum**

```shell
yum clean all
```

清理之前（CentOS）的缓存

执行效果如下

![1576838137800](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576838137800.png)

```shell
yum makecache
```

就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。

执行效果如下

![1576838150825](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576838150825.png)

如上图，元数据缓存已建立,缓存成功。

**5、验证yum源使用**

```shell
yum search tomcat
```

执行效果如下

![1576836672011](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576836672011.png)

如上图所示，我们发现，现在查找软件信息使用了上面的yum缓存。

Loading mirror speeds from cached hostfile(从缓存的主机文件加载镜像速度)

 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com

> 总结
>
> yum -y install 软件包
>
> 卸载软件
> yum -y remove 软件包
>
> 查找软件
>
> yum list *
>
> yum源
>
> 版本:
>
> 比如我们使用的是CentOS7，在下载CentOS-Base.repo的时候要注意它的版本。

## 4.2 rpm使用

```
RPM包管理类似于windows下的“添加/删除程序”但是功能却比“添加/删除程序”强大很多
```

**1、rpm介绍**

rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。

**2、rpm与yum区别**

rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。

语法如下：

```shell
用法: rpm [选项...]
```

**rpm包**

![1577255859260](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577255859260.png)

> 注意：
>
> 以上为扩展名为.rpm的包
>
> 可以理解成是Windows中的.exe文件

**安装rpm软件包**

```shell
rpm -ivh 软件全包名
```

**卸载rpm软件包**

```shell
rpm -e 软件全包名      
```

**列出所有安装过的包**

```shell
rpm -qa
```

**查询软件包信息**

```shell
rpm -qi 软件全包名
```

**查看文件安装位置** 

```shell
rpm -ql 软件全包名
```

## 4.3 shell使用

```
shell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。
而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。
```

### 4.3.1 shell入门

```
通过简单的学习，我们编写一个简单的入门shell程序。
我们通过前面学习的echo命令，在shell脚本中打印出一句话。
echo $SHELL
```



<font color="red">运行脚本</font>

```shell
bash ./a.sh
./a.sh
bash a.sh
```



**1) 什么是shell**

程序第一行：(要写！！！！！！！！！！！！！！！)

```shell
#!/bin/bash
```



![image-20210305083758669](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305083758669.png)



![image-20210305083828885](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305083828885.png)





Shell 脚本（shell script），是一种为 shell 编写的脚本程序。

[Shell](https://www.leiue.com/tags/shell) [脚本](https://www.leiue.com/tags/脚本)（[Shell Script](https://www.leiue.com/tags/shell-script)）又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作

![1576838959401](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576838959401.png)



Shell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果。利用 shell 脚本可以进行系统管理，文件操作等。

在 Unix 及所有的系统中，如 Linux、FreeBSD 等操作系统，都存在 shell 脚本。依照 Unix shell 的各种不同类型，shell 脚本也有各种不同方言。在 DOS、OS/2、Microsoft Windows 中的批处理文件，跟 shell 脚本有类似的功能。

**2) shell环境**

```
java需要虚拟机解释器, 同理 shell脚本也需要解释器
```

Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

**查看解释器**

```shell
cat /etc/shells
```

执行效果如下

![1577068054836](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577068054836.png)

Linux 的 Shell 种类众多，常见的有：

- Bourne Shell（/usr/bin/sh或/bin/sh）
- Bourne Again Shell（/bin/bash）
- C Shell（/usr/bin/csh）
- K Shell（/usr/bin/ksh）
- Shell for Root（/sbin/sh）

- 等等……

我们当前课程使用的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell

**3) 编写第一个shell**



![image-20210305083729192](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305083729192.png)



现在，我们打开文本编辑器(我们也可以使用 vi/vim 命令来创建文件)，新建一个文件 czbk.sh，扩展名为 sh（sh代表shell）：

```shell
#!/bin/bash  --- 指定脚本解释器
echo "你好，传智播客 !"
```

//写shell的习惯 第一行指定解释器

//文件是sh为后缀名

//括号成对书写

//注释的时候尽量不用中文注释。不友好。

//[] 括号两端要要有空格。  [ neirong ]

//习惯代码索引，增加阅读性

//写语句的时候，尽量写全了，比如if。。。

1、创建sh文件**

```shell
vim czbk.sh
```

**2、编写并保存**

![1576839380199](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576839380199.png)

**3、查看czbk.sh文件**

```shell
ls -l
```

![1576839550390](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576839550390.png)

如上图，我们发现刚刚编写的czbk.sh文件的的权限是【-rw-rw-r--】，通过我们之前学过的知识，我们发现这个文件并没有执行的权限

我们需要将czbk.sh文件设置下它的执行权限【x】，如果不设置有执行权限，当前的文件不具备文件执行的能力。

**通过chmod设置执行权限**

```shell
chmod +x ./czbk.sh
```

执行效果如下

![1576839765609](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576839765609.png)

我们发现，czbk.sh拥有了【x】执行权限

下面，我们就开始执行czbk.sh

**4、执行czbk.sh文件** --- bash a.sh0

```shell
 ./czbk.sh 
```

执行效果如下：

![1576839880567](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1576839880567.png)

如上图，我们刚刚编写的shell在执行的时候正常打印出来了，说明czbk.sh具备执行的能力

> 注意：
>
> **#!** 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。
>
> echo 命令用于向窗口输出文本。

### 4.3.2 shell注释

```
引子：
在Java SE课程中，我们也学习了注释
比如单行注释我们使用双斜杠//
   多行注释我们使用/**开头表示注释多行
而在shell编程中，我们同样也要有注释，注释掉程序中不用的脚本
```

**1、单行注释**

以 **#** 开头的行就是注释，会被解释器忽略。

通过每一行加一个 **#** 号设置多行注释，如下：

```shell
#--------------------------------------------
# 这是一个注释
#--------------------------------------------
##### 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 结束  #####
```

如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？

每一行加个#符号太费力了，此时，我们可以通过EOF进行多行注释，如下：

**2、多行注释**

多行注释还可以使用以下格式：

```shell
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

EOF 也可以使用其他符号:

```shell
:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

> 总结：
>
> 我们将在下面的小章节中使用注释，查看注释效果

### 4.3.3 shell变量

```
引子：
这里的变量我们可以理解为我们在Java SE阶段定义的变量，比如在SE中我定义一个字符串类型的变量使用String stringStr="";

注意：下面的演示我们还是继续沿用test-shell.sh进行测试
```

**1、定义变量:**



![image-20210305085343651](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305085343651.png)

![image-20210305090152778](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305090152778.png)



![image-20210305090342978](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305090342978.png)



![image-20210305090422378](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305090422378.png)



![image-20210305090712585](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305090712585.png)



```
variable_name="czbk"
```

变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：

- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
- 中间不能有空格，可以使用下划线（_）。
- 不能使用标点符号。
- 不能使用bash里的关键字（可用help命令查看保留关键字）。

有效的 Shell 变量名示例如下：

```shell
RUNOOB
LD_LIBRARY_PATH
_var
var2
```

无效的变量命名：

```shell
?var=123
user*name=runoob
```

------

**2、使用变量**

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```shell
variable_name="czbk"
echo $variable_name
echo ${variable_name}
```

 执行效果如下

![1577175492599](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175492599.png)

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：

```shell
 echo "I am good at ${shell-t}Script"
```

通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo "I am good at $shell-tScript"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。这里我们推荐给所有变量加上花括号，这也是一个好的编程习惯。

已定义的变量，可以被重新定义，如：

```shell
your_name="tom"
echo $your_name
your_name="frank"
echo $your_name
```

执行效果如下图

![1577175655898](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175655898.png)

这样写是合法的，但注意，第二次赋值的时候不能写$your_name="frank"，使用变量的时候才加$。

**3、只读变量**

```
这里的只读变量其实有点类似于我们在java se阶段课程中定义的final变量，即在程序的上下文中不允许被程序修改
```

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

下面的例子尝试更改只读变量，结果报错：

```shell
#!/bin/bash
myUrl="https://www.baidu.com"
readonly myUrl
myUrl="https://cn.bing.com/"
```

 执行效果如下图

![1577175714493](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175714493.png)

**4、删除变量**

使用 unset 命令可以删除变量。语法：

```
unset variable_name
```

变量被删除后不能再次使用。unset 命令不能删除只读变量。

**示例如下**

```shell
#!/bin/sh
myUrl="https://www.baidu.com"
unset myUrl
echo $myUrl
```

执行效果如下图

![1577175804257](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175804257.png)

如上面的shell脚本，我们定义了一个myUrl变量，通过unset删除这个变量，然后通过echo进行输出，结果是就是为空，没有任何的结果输出。

------

**Shell 字符串**

```
字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，正如我们开篇提到的，在Java SE中我们定义一个字符串可以通过Stirng  stringStr=“abc" 双引号的形式进行定义，而在shel中也是可以的。
```

**单引号**

```shell
str='this is a string variable'
```

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

**双引号**

```shell
your_name='frank'
str="Hello,  \"$your_name\"! \n"
echo -e $str
```

输出结果为：

![1577175850350](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175850350.png)

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

**拼接字符串**

```shell
your_name="frank"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
```

输出结果为：

![1577175902317](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175902317.png)

**获取字符串长度**

```shell
string="czbk"
echo ${#string}
```

输出结果：4.表示长度为4

![1577175975730](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175975730.png)

**提取字符串**

以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：

```shell
string="abcdefghijklmn"
echo ${string:1:4} 
```

 执行效果如下

![1577176031872](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577176031872.png)

输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。

### 4.3.4 shell数组



![image-20210305090857993](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305090857993.png)





```
这里的数组和我们在Java SE阶段的数组结果（或是性质）是一样的，只是定义的过程大同小异
```

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

**定义数组**

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如下：

```shell
数组名=(值1 值2 ... 值n)
```

例如：

```shell
array_name=(value0 value1 value2 value3)
```

或者

```shell
array_name=(
value0
value1
value2
value3
)
```

通过下标定义数组中的其中一个元素：

```shell
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
```

可以不使用连续的下标，而且下标的范围没有限制。

**读取数组**

读取数组元素值的一般格式是：

```shell
${数组名[下标]}
```

例如：

```shell
valuen=${array_name[n]}
```

使用 **@** 符号可以获取数组中的所有元素，例如：

```shell
echo ${array_name[@]}
```

**获取数组的长度**

获取数组长度的方法与获取字符串长度的方法相同，例如：

```shell
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
```

下面，我们通过一个例子，定义数组、提取数组元素的例子来验证下

```shell
#! /bin/bash
g=(a b c d e f)
echo "数组下标为2的数据为:" ${g[2]}
echo  "数组所有数据为:"  ${#g[@]}
echo  "数组所有数据为:"   ${#g[*]}
```

如下

![1577067300329](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577067300329.png)

 执行效果如下：

![1577067402285](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577067402285.png)

### 4.3.5 shell运算符

![image-20210305092626460](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305092626460.png)



条件表达式

![image-20210305093714436](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305093714436.png)



![image-20210305093911688](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305093911688.png)



```shell
#判断字符串是否为空,不为空，就是0
# [ $a ]
[ $ "${a}" ]

#获取字符串长度
${#a}
```



关系运算符

![image-20210305095705043](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305095705043.png)



布尔运算符（0为真，1为假）

![image-20210305100508506](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305100508506.png)



逻辑运算符

![image-20210305101247077](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305101247077.png)





 







----------------------------------------------------------------------------------------------------------------------------------------------------









```shell
val=`expr 2 + 2`
echo "相加之后的结果为：" $val
```



```
我们在前面课程中学习Java SE中也学到了运算符，比如算术、关系、布尔等，而在sehll编程中同样也有运算符，虽然表达的方式不一样，但是最终的目的都是一样的，都是为了解决编程中现存问题
```

Shell 和其他编程一样，**支持**包括：算术、关系、布尔、字符串等运算符。

原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加,我们还是利用上面的例子test-shell.sh 

**1、算数运算符**

```
val=`expr 2 + 2`
echo "相加之后的结果为：" $val
```

 执行效果如下

![1577068429739](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577068429739.png)

注意：

**表达式和运算符之间要有空格**，例如 2+2 是不对的，必须写成 2 + 2。

完整的表达式要被 **`** 包含，注意不是单引号。

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

| **运算符** | **说明**                                      | **举例**                      |
| ---------- | --------------------------------------------- | ----------------------------- |
| +          | 加法                                          | `expr $a + $b` 结果为 30。    |
| -          | 减法                                          | `expr $a - $b` 结果为 -10。   |
| *          | 乘法                                          | `expr $a \* $b` 结果为  200。 |
| /          | 除法                                          | `expr $b / $a` 结果为 2。     |
| %          | 取余                                          | `expr $b % $a` 结果为 0。     |
| =          | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |
| ==         | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |
| !=         | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |

**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。

下面是运算符shell脚本（还是采用之前的例子test-shell.sh ）w

```shell
#! /bin/bash
#g=(a b c d e f)
#echo "数组下标为2的数据为:" ${g[2]}
#echo  "数组所有数据为:"  ${#g[@]}
#echo  "数组所有数据为:"   ${#g[*]}
:<<EOF
val= `expr 2 + 2`
echo "相加之后的结果为：" $val
EOF

a=4
b=20
echo “加法运算”  `expr $a + $b`
echo “减法运算”  `expr $a - $b`
echo “乘法运算，注意*号前面需要反斜杠” ` expr $a \* $b`
echo “除法运算”  `expr  $b / $a`
((a++))
echo "a = $a"
c=$((a + b)) 
d=$[a + b]
echo "c = $c"
echo "d = $d"
```

**上面的shell命令#开头的为单行注释**

**:<<EOF 开头和EOF结尾的为多行注释**

执行效果如下

![1577152161538](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577152161538.png)

**2、字符串运算符**

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                      | 举例                     |
| :----- | :---------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。       |

**字符串运算符实例如下（还是采用之前的例子test-shell.sh ）：**

```shell
a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi
 
```

 执行效果如下

![1577158474734](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577158474734.png)

**3、关系运算符**

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                       |
| :----- | :---------------------------------------------------- | :------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |

**关系运算符（还是采用之前的例子test-shell.sh ）**

```shell
a=10
b=20

if [ $a -eq $b ]
then
   echo "$a -eq $b : a 等于 b"
else
   echo "$a -eq $b: a 不等于 b"
fi
if [ $a -ne $b ]
then
   echo "$a -ne $b: a 不等于 b"
else
   echo "$a -ne $b : a 等于 b"
fi
if [ $a -gt $b ]
then
   echo "$a -gt $b: a 大于 b"
else
   echo "$a -gt $b: a 不大于 b"
fi
if [ $a -lt $b ]
then
   echo "$a -lt $b: a 小于 b"
else
   echo "$a -lt $b: a 不小于 b"
fi
if [ $a -ge $b ]
then
   echo "$a -ge $b: a 大于或等于 b"
else
   echo "$a -ge $b: a 小于 b"
fi
if [ $a -le $b ]
then
   echo "$a -le $b: a 小于或等于 b"
else
   echo "$a -le $b: a 大于 b"
fi
```

执行效果如下：

![1577169772803](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577169772803.png)

**4、布尔运算符**

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                     |
| :----- | :-------------------------------------------------- | :--------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

**布尔运算符实例如下（还是采用之前的例子test-shell.sh ）：**

```shell
a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi

```

执行效果如下

![1577170810671](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577170810671.png)

**5、逻辑运算符**

假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                       |
| :----- | :--------- | :----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |

**逻辑运算符实例如下（还是采用之前的例子test-shell.sh ）：** 

```shell
a=10
b=20

if [[ $a -lt 100 && $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi
```

执行效果如下

![1577171478166](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577171478166.png)



### 4.3.6 shell流程控制

```
在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句；
在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。
```

#### **1、if 语句：**



![image-20210305101548978](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305101548978.png)



**主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh**

```shell
if condition
then
    command1 
    command2
    ...
    commandN 
fi
```

 比如，我们现在通过前面学习的知识查找一个进程，如果进程存在就打印true

```shell
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
```

> 注意
>
> 末尾的fi就是if倒过来拼写

执行效果如下

![1577174880068](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577174880068.png)

#### **2、if else 语句：**

**主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。**

```shell
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
```

上接上面的例子，如果找不到sshAAA**（此处可以随便输入一个）**进程，我们就打印false

```shell
if [ $(ps -ef | grep -c "sshAAA") -gt 1 ]; then echo "true";  else echo "false"; fi
```

执行效果如下

![1577175009088](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577175009088.png)

#### **3、if else-if else 语句：**

**主要用于判断，相当于java se中的if else-if else**

```shell
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

以下实例判断两个变量是否相等

我们继续使用上面的例子（test-shell.sh ）

```shell
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

执行效果如下

![1577152946471](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577152946471.png)

#### **4、for 循环**



![image-20210305105124319](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305105124319.png)



**主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh**

for循环格式为

```shell
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

顺序输出当前列表中的字母：

```shell
for loop in A B C D E F G 
do
    echo "顺序输出字母为: $loop"
done
```

执行效果如下

![1577153230698](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577153230698.png)



#### **5、while循环**



![image-20210305105341455](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305105341455.png)



主要用于循环，相当于java se中的while循环

while循环用于不断执行一系列命令，也用于从输入文件中读取数据 

语法格式为

```
while condition
do
    command
done
```

以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 

还是采用之前的例子test-shell.sh

```shell
#!/bin/bash
int=1
while(( $int<=10 ))
do
    echo "输出的值为："$int
    let "int++"
done
```

执行效果如下图

**![1577153468616](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577153468616.png)**

#### **6、case ... esac语句**



![image-20210305104906569](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305104906569.png)





**主要用于分支条件选择，相当于java se中的switch case循环**

**case ... esac** 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。

还是采用之前的例子test-shell.sh

case ... esac 语法格式如下：

```shell
case 值 in
模式1)
    command1
    command2
    command3
    ;;
模式2）
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac
```

case 后为取值，值可以为变量或常数。

值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。

下面通过v的值进行case--esac

```shell
v="czbk"

case "$v" in
   "czbk") echo "传智播客"
   ;;
   "baidu") echo "baidu 搜索"
   ;;
   "google") echo "google 搜索"
   ;;
esac
```

执行效果如下

![1577153795748](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577153795748.png)



### 4.3.7 shell函数

第一种:无参无返回值

![image-20210305111813638](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305111813638.png)

第二种：有参数无返回值   第三种：有参数有返回值

![image-20210305111930426](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305111930426.png)







```
我们将要学习的shell函数，我们可以理解成在Java SE阶段我们学习的方法，它和shell函数的作用是一样的。
```

函数语法如下：

```shell
[ function ] funname [()]

{

    action;

    [return int;]

}
```

> 注意：
>
> - 1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。
> - 2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

下面我们将定义一个函数，并发生函数调用

还是采用之前的例子test-shell.sh

```shell
#!/bin/bash

czbk(){
    echo "这是第一个函数!"
}
echo "-----这里是函数开始执行-----"
czbk
echo "-----这里是函数执行完毕-----"
```

执行效果如下图

![1577159360606](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\1577159360606.png)

下面，我们定义一个带有return语句的函数：

```shell
function czbk(){
    echo "对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
czbk
echo "输入的两个数字之和为 $? !"
```

> 注意：
>
> 函数返回值在调用该函数后通过 $? 来获得。
>
> 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。



### 4.3.8 read命令

![image-20210305112704509](D:\java学习\1.Java基础\06.集合\14.【List、Set】\14.【List、Set】-笔记\就业班-day03-List、Set、数据结构、Collections\img\image-20210305112704509.png)





### 4.3.9 总结

在企业级开发过程中，我们（开发人员）学习Linux主要的目的就是在Linux系统中能够熟练的操作目录、文件，还有就是通过所学的命令系统化的编写sh文件，所以，在当前章节中，我们要熟练的编写shell脚本相关命令以及综合案例中的知识点。